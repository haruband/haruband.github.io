
<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://haruband.github.io/js/theme.min.js" integrity="sha384-pb++s6uBRKaQv+iAXpgA/H3IlpLZdO14tTwuCI7uXmz4aaZdByoCcM+6BhynMq/1"></script>
  <link rel="stylesheet" href="https://haruband.github.io/abridge.css?h=98ebdf6fd3d59dfb2edf" />
  <meta charset="utf-8" />
  <meta http-equiv="x-ua-compatible" content="ie=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="base" content="https://haruband.github.io" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <meta name="theme-color" content="#333333" />
  <meta name="msapplication-TileColor" content="#333333" />
  <link rel="manifest" href="https://haruband.github.io/manifest.min.json" />
  <link rel="mask-icon" href="https://haruband.github.io/safari-pinned-tab.svg" color="#ff9900" />
  <link rel="icon" type="image/svg+xml" href="https://haruband.github.io/favicon.svg" />
  <link rel="apple-touch-icon" sizes="180x180" href="https://haruband.github.io/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="https://haruband.github.io/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="https://haruband.github.io/favicon-16x16.png" />
  <link rel="alternate" type="application/atom+xml" title="CodeBook Atom Feed" href="https://haruband.github.io/atom.xml" />
  <meta name="robots" content="index, follow" />
  <meta name="googlebot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <meta name="bingbot" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <title>[Arrow/Datafusion] 동작 과정 분석 (Join) | CodeBook</title>
  <meta name="author" content="Inhyeok Kim" />
  <meta name="copyright" content="CodeBook" />
  <meta name="description" content="Haruband&#x27;s TechBlog" />
  <link rel="canonical" href="https://haruband.github.io/datafusion-join/" />
  <meta name="keywords" content="Arrow, Datafusion, Kubernetes" />
  <meta name="google-site-verification" content="Your Google Site verification code." />
  <meta name="msvalidate.01" content="Your Bing Site verification code." />
  <meta property="og:url" content="https://haruband.github.io/datafusion-join/" />
  <meta name="twitter:url" content="https://haruband.github.io/datafusion-join/" />
  <meta property="og:description" content="Haruband&#x27;s TechBlog" />
  <meta name="twitter:description" content="Haruband&#x27;s TechBlog" />
  <meta property="og:title" content="[Arrow&#x2F;Datafusion] 동작 과정 분석 (Join) | CodeBook" />
  <meta name="twitter:title" content="[Arrow&#x2F;Datafusion] 동작 과정 분석 (Join) | CodeBook" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:image" content="https://haruband.github.io/banner.png" />
  <meta property="og:image" content="https://haruband.github.io/banner.png" />
  <meta property="og:site_name" content="CodeBook" />
  <meta property="og:locale" content="en_US" />
  <meta property="og:type" content="website" />
  <meta property="og:updated_time" content="2024-11-25" />
  <meta name="twitter:site" content="@your-user-name" />
  <meta name="twitter:creator" content="@your-user-name" />
  <script defer src="https://haruband.github.io/js/abridge.min.js?h=e0f9a881a665c86cce9c" integrity="sha384-QF67y7RnPkuDrJNQqn3/7nYxqxWkW/qHI7zN0WTES1aXbf+TotoByRBb835fUE6U"></script>
  <noscript><link rel="stylesheet" href="https://haruband.github.io/nojs.css" /></noscript>
</head>
<body>
  <header>
    <nav>
      <div><big><a href="https://haruband.github.io" title="CodeBook">CodeBook</a></big></div>
      <div>

        <div>
          <ul><li><a class="s110" href="https://haruband.github.io/archive/"> Posts </a></li><li><a class="s110" href="https://haruband.github.io/tags/"> Tags </a></li><li><i type="reset" id="mode" class="js svgs adjust"></i></ul>
        </div>

        <div>
          <div>
            <form autocomplete=off class="js" name="goSearch" id="searchbox">
              <div class="searchd">
                <input id="searchinput" type="text" placeholder="Search" title="Search" />
                <button type="submit" title="Search" class="svgs svgm search"></button>
              </div>
              <div class="results"><div id="suggestions"></div></div>
            </form>
          </div>
        </div>

      </div>
    </nav>
  </header>
  <main>
    <article>
      <h1><a href="https://haruband.github.io/datafusion-join/">[Arrow&#x2F;Datafusion] 동작 과정 분석 (Join)</a></h1>

      <span class="s95"> Inhyeok Kim <span class="rpad"></span> November 25, 2024 <span class="rpad"></span>Updated: November 25, 2024 <span class="rpad"></span> #<a href="https://haruband.github.io/tags/arrow/">Arrow</a>  #<a href="https://haruband.github.io/tags/datafusion/">Datafusion</a> </span>

    
        <div class="block">
      <div class="blockdiv">
        <a class="b s150" href="https://haruband.github.io/tags/datafusion/">Datafusion (Series)</a><br>
            <a href="https://haruband.github.io/datafusion-overview/">[Arrow&#x2F;Datafusion] 동작 과정 분석</a><br>
            <a href="https://haruband.github.io/datafusion-aggregation/">[Arrow&#x2F;Datafusion] 동작 과정 분석 (Aggregation)</a><br>
            <a class="scur" href="https://haruband.github.io/datafusion-join/">[Arrow&#x2F;Datafusion] 동작 과정 분석 (Join)</a><br> 
          
            <a href="https://haruband.github.io/datafusion-benchmark/">[Arrow&#x2F;Datafusion] 성능 평가 (Spark)</a><br>
      </div>
    </div>


<p>대부분의 SQL 엔진에서 성능 향상을 위해 가장 많이 신경쓰는 부분은 바로 조인(Join)일 것이다. 그래서 다양한 조건의 조인을 처리하는 여러 가지 동작 방식이 존재하고, 다양한 상황을 고려하여 최선의 동작 방식을 선택하는 것이 필수이다. 오늘은 Datafusion 에서 어떤 방식으로 조인을 처리하는지, 어떤 방법으로 최적화되는지 살펴보도록 하자.</p>
<p>조인을 처리하는 방식에 가장 큰 영향을 주는 등가(Equal) 조건의 유무에 따라 조인을 어떻게 처리하는지 살펴보자.</p>
<pre data-lang="sql" class="language-sql z-code"><code class="language-sql" data-lang="sql"><span class="z-source z-sql"><span class="z-keyword z-other z-DML z-sql">select</span> <span class="z-variable z-language z-star z-sql">*</span> <span class="z-keyword z-other z-DML z-sql">from</span> left <span class="z-keyword z-other z-DML z-sql">inner join</span> right on <span class="z-constant z-other z-database-name z-sql">left</span>.<span class="z-constant z-other z-table-name z-sql">country</span> <span class="z-keyword z-operator z-comparison z-sql">=</span><span class="z-keyword z-operator z-comparison z-sql">=</span> <span class="z-constant z-other z-database-name z-sql">right</span>.<span class="z-constant z-other z-table-name z-sql">country</span> <span class="z-keyword z-operator z-logical z-sql">and</span> <span class="z-constant z-other z-database-name z-sql">left</span>.<span class="z-constant z-other z-table-name z-sql">job</span> <span class="z-keyword z-operator z-comparison z-sql">=</span><span class="z-keyword z-operator z-comparison z-sql">=</span> <span class="z-constant z-other z-database-name z-sql">right</span>.<span class="z-constant z-other z-table-name z-sql">job</span>
</span></code></pre>
<p>위의 쿼리는 두 개 컬럼[country, job]에 대한 등가 조건을 포함하고 있고, 아래와 같은 논리 계획으로 변환되어 일반적으로 두 가지 방식(HashJoin/SortMergeJoin)으로 실행된다.</p>
<pre class="z-code"><code><span class="z-text z-plain">Inner Join: left.country = right.country, left.job = right.job
</span><span class="z-text z-plain">  TableScan: left projection=[country, job, salary]
</span><span class="z-text z-plain">  TableScan: right projection=[country, job, salary]
</span></code></pre>
<p>우선, 대부분 가장 좋은 성능을 보여주는 HashJoin 부터 살펴보자. 이는 아래 그림처럼 작은 테이블을 이용하여 해시 테이블을 먼저 만들고, 큰 테이블을 순서대로 비교하면서 처리하는 방식이다. 해시를 이용하기 때문에 큰 테이블에 있는 데이터가 작은 테이블에 있는지 비교하는 비용은 O(1) 이지만, 해시 테이블을 메모리에 유지하는 비용이 문제가 될 수 있다. 그래서 테이블의 크기가 작다면 하나의 해시 테이블을 만드는 방식(CollectLeft)을 사용하고, 테이블의 크기가 크다면 조건 컬럼[country, job]의 해시를 이용해서 나눈 다음 파티션별로 해시 테이블을 만드는 방식(Partitioned)을 사용한다.</p>
<p><img src="https://haruband.github.io/datafusion-join/./join2.png" alt="join2.png" /></p>
<p>조인에 사용되는 두 개의 테이블 중에 크기가 충분히 작은 테이블이 있다면 아래와 같은 실행 계획으로 변환된다.</p>
<pre class="z-code"><code><span class="z-text z-plain">HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(country@0, country@0), (job@1, job@1)]
</span><span class="z-text z-plain">  CsvExec: file_groups={1 group: [[left.csv]]}, projection=[country, job, salary], output_ordering=[country@0 ASC NULLS LAST], has_header=true
</span><span class="z-text z-plain">  RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
</span><span class="z-text z-plain">    CsvExec: file_groups={1 group: [[right.csv]]}, projection=[country, job, salary], output_ordering=[country@0 ASC NULLS LAST], has_header=true
</span></code></pre>
<p>위의 실행 계획은 작은 테이블(left.csv)을 이용하여 해시 테이블을 먼저 만들고, 큰 테이블(right.csv)은 두 개의 파티션으로 나눈 다음 앞에서 만든 해시 테이블을 이용하여 비교한다. 분산 처리 엔진(Spark)은 마스터 노드에서 해시 테이블을 만들어서 워커 노드로 전송하기 때문에 오버헤드가 크지만, Datafusion 은 하나의 프로세스 내에서 간단히 해시 테이블을 공유해서 사용한다.</p>
<p>조인에 사용되는 두 개의 테이블 중에 크기가 충분히 작은 테이블이 없다면 아래와 같은 실행 계획으로 변환된다.</p>
<pre class="z-code"><code><span class="z-text z-plain">HashJoinExec: mode=Partitioned, join_type=Inner, on=[(country@0, country@0), (job@1, job@1)]
</span><span class="z-text z-plain">  RepartitionExec: partitioning=Hash([country@0, job@1], 2), input_partitions=2
</span><span class="z-text z-plain">    RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
</span><span class="z-text z-plain">      CsvExec: file_groups={1 group: [[left.csv]]}, projection=[country, job, salary], output_ordering=[country@0 ASC NULLS LAST], has_header=true
</span><span class="z-text z-plain">  RepartitionExec: partitioning=Hash([country@0, job@1], 2), input_partitions=2
</span><span class="z-text z-plain">    RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
</span><span class="z-text z-plain">      CsvExec: file_groups={1 group: [[right.csv]]}, projection=[country, job, salary], output_ordering=[country@0 ASC NULLS LAST], has_header=true
</span></code></pre>
<p>위의 실행 계획은 두 테이블을 각각 두 개의 파티션으로 나눈 다음, 조건 컬럼[country, job]의 해시를 이용하여 파티션을 재분배한다. 이렇게 되면 같은 조건 컬럼을 가지는 두 테이블의 모든 행(row)은 같은 파티션으로 모이기 때문에 파티션별로 해시 테이블을 만들어서 처리하면 된다.</p>
<p>다음으로, SortMergeJoin 을 살펴보자. 이는 아래 그림처럼 두 개의 테이블을 정렬한 다음 순차적으로 비교하면서 처리하는 방식이다. 정렬된 두 개의 테이블이 어떤 순서로 처리되는지 번호로 표시를 해두었다. 원리는 단순한데, 두 개의 테이블을 비교해서 오른쪽 테이블의 행(row)이 크면 왼쪽 테이블의 다음 행으로 넘어가고, 왼쪽 테이블의 행이 크면 오른쪽 테이블의 다음 행으로 넘어간다. 이런 방식으로 하면 빠짐없이 같은 조건 컬럼을 가지는 모든 행의 조합을 찾을 수 있다.</p>
<p><img src="https://haruband.github.io/datafusion-join/./join1.png" alt="join1.png" /></p>
<p>SortMergeJoin 을 사용했을 때의 실행 계획은 아래와 같다.</p>
<pre class="z-code"><code><span class="z-text z-plain">SortMergeJoin: join_type=Inner, on=[(country@0, country@0), (job@1, job@1)]
</span><span class="z-text z-plain">  SortExec: expr=[country@0 ASC, job@1 ASC], preserve_partitioning=[true]
</span><span class="z-text z-plain">    RepartitionExec: partitioning=Hash([country@0, job@1], 2), input_partitions=2
</span><span class="z-text z-plain">      RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
</span><span class="z-text z-plain">        CsvExec: file_groups={1 group: [[left.csv]]}, projection=[country, job, salary], output_ordering=[country@0 ASC NULLS LAST], has_header=true
</span><span class="z-text z-plain">  SortExec: expr=[country@0 ASC, job@1 ASC], preserve_partitioning=[true]
</span><span class="z-text z-plain">    RepartitionExec: partitioning=Hash([country@0, job@1], 2), input_partitions=2
</span><span class="z-text z-plain">      RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
</span><span class="z-text z-plain">        CsvExec: file_groups={1 group: [[right.csv]]}, projection=[country, job, salary], output_ordering=[country@0 ASC NULLS LAST], has_header=true
</span></code></pre>
<p>위의 실행 계획은 두 테이블을 각각 두 개의 파티션으로 나눈 다음, 조건 컬럼[country, job]의 해시를 이용하여 파티션을 재분배한다. 그리고 파티션별로 정렬한 다음 순차적으로 비교하면서 처리한다.</p>
<p>아래와 같이 등가 조건이 없는 비등가 조인은 어떻게 처리되는지 살펴보자.</p>
<pre data-lang="sql" class="language-sql z-code"><code class="language-sql" data-lang="sql"><span class="z-source z-sql"><span class="z-keyword z-other z-DML z-sql">select</span> <span class="z-variable z-language z-star z-sql">*</span> <span class="z-keyword z-other z-DML z-sql">from</span> left <span class="z-keyword z-other z-DML z-sql">inner join</span> right on <span class="z-constant z-other z-database-name z-sql">left</span>.<span class="z-constant z-other z-table-name z-sql">salary</span> <span class="z-keyword z-operator z-comparison z-sql">&gt;</span> <span class="z-constant z-other z-database-name z-sql">right</span>.<span class="z-constant z-other z-table-name z-sql">salary</span>
</span></code></pre>
<p>위의 쿼리는 아래와 같은 논리 계획으로 변환된다.</p>
<pre class="z-code"><code><span class="z-text z-plain">Inner Join:  Filter: left.salary &gt; right.salary
</span><span class="z-text z-plain">  TableScan: left projection=[country, job, salary]
</span><span class="z-text z-plain">  TableScan: right projection=[country, job, salary]
</span></code></pre>
<p>비등가 조인은 일반적으로 두 가지 방식(NestedLoopJoin/CrossJoin)으로 처리된다. 동작 원리는 간단한데, 아래처럼 두 테이블의 가능한 조합을 모두 확인한다고 보면 된다. 그래서 성능적인 문제가 있기 때문에 꼭 필요할 때만 사용되는 방식이다.</p>
<p><img src="https://haruband.github.io/datafusion-join/./join0.png" alt="join0.png" /></p>
<p>아래는 NestedLoopJoin 을 사용했을 때의 실행 계획이다.</p>
<pre class="z-code"><code><span class="z-text z-plain">NestedLoopJoinExec: join_type=Inner, filter=salary@0 &gt; salary@1
</span><span class="z-text z-plain">  CsvExec: file_groups={1 group: [[left.csv]]}, projection=[country, job, salary], output_ordering=[country@0 ASC NULLS LAST], has_header=true
</span><span class="z-text z-plain">  RepartitionExec: partitioning=RoundRobinBatch(2), input_partitions=1
</span><span class="z-text z-plain">    CsvExec: file_groups={1 group: [[right.csv]]}, projection=[country, job, salary], output_ordering=[country@0 ASC NULLS LAST], has_header=true
</span></code></pre>
<p>위의 실행 계획은 큰 테이블(right.csv)을 두 개의 파티션으로 나눈 다음 작은 테이블(left.csv)과 가능한 조합을 모두 확인한다. 앞의 HashJoin 은 작은 테이블이 충분히 작지 않다면 여러 개의 파티션으로 나누어서 처리하는 것이 가능하지만, NestedLoopJoin 에서는 작은 테이블을 나누면 모든 조합을 확인할 수 없기 때문에 큰 테이블만 나누어서 처리하는 것이 가능하다.</p>
<p>지금까지 Datafusion 에서 조인이 어떻게 동작하는지 살펴보았다. 이외에도 다양한 최적화 기술들을 이미 지원하고 있고, 앞으로 지원될 예정인 기술들도 많으니 기회될 때마다 소개드리도록 하겠다.</p>

      <nav>
        <div>
          <a href="https://haruband.github.io/datafusion-benchmark/">&#8249; [Arrow&#x2F;Datafusion] 성능 평가 (Spark)</a>
        </div>
        <div>
          <a href="https://haruband.github.io/datafusion-aggregation/"> [Arrow&#x2F;Datafusion] 동작 과정 분석 (Aggregation) &#8250;</a>
        </div>
      </nav>
    </article>

    <div class="sblock">
      <div class="blockdiv">
        <a class="b s150" href="https://haruband.github.io/tags/datafusion/">Series</a><br>
            
      <a href="https://haruband.github.io/datafusion-overview/">[Arrow&#x2F;Datafusion] 동작 과정 분석</a><br>
            
      <a href="https://haruband.github.io/datafusion-aggregation/">[Arrow&#x2F;Datafusion] 동작 과정 분석 (Aggregation)</a><br>
            
      <a class="scur" href="https://haruband.github.io/datafusion-join/">[Arrow&#x2F;Datafusion] 동작 과정 분석 (Join)</a><br>
    
            
      <a href="https://haruband.github.io/datafusion-benchmark/">[Arrow&#x2F;Datafusion] 성능 평가 (Spark)</a><br>
      </div>
  </main>
  <footer>
    <div class="c">
      <nav class="tpad"><div><a href="https://www.linkedin.com/in/inhyeok-kim-7620a0b0/" target="_blank" title="LinkedIn"><i type="Button" class="svg linkedin" title="LinkedIn"></i></a><a href="https://github.com/haruband/" target="_blank" title="Github"><i type="Button" class="svg github" title="Github"></i></a></div></nav>
      <nav class="vpad">
        <a class="rpad s90" href="https://haruband.github.io/about/"> About </a>
        <a class="rpad s90" href="https://haruband.github.io/contact/"> Contact </a>
      </nav>
      <p class="s80"> &copy; <span id="year">2025</span> CodeBook</p>
      <p class="s80">Powered by <a href="https://www.getzola.org/" target="_blank">Zola</a> & <a href="https://github.com/jieiku/abridge/" target="_blank">Abridge</a></p>
    </div>
  </footer><span class="topout">
<span class="topleft"> </span><a href="#" class="top" title="Back to Top"><i class="svgs svgh angu"></i></a>
</span>
</body>
</html>
