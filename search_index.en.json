{"fields":["title","description","body"],"pipeline":["trimmer","stopWordFilter","stemmer"],"ref":"id","version":"0.9.5","index":{"body":{"root":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.4142135623730951},"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":2.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":2.6457513110645907},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":9,".":{"docs":{},"df":0,"5":{"docs":{},"df":0,"5":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}},"8":{"docs":{},"df":0,"1":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}},"5":{"docs":{},"df":0,":":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}}},":":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.7320508075688772}},"df":1}},"x":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.7320508075688772}},"df":1},"1":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":1},"d":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":1}},"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.4142135623730951}},"df":1},"c":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}},"4":{"docs":{},"df":0,"3":{"docs":{},"df":0,"4":{"docs":{},"df":0,"7":{"docs":{},"df":0,"0":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"5":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1}},"7":{"docs":{},"df":0,"9":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.4142135623730951}},"df":1}},"8":{"docs":{},"df":0,"5":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}},"b":{"docs":{},"df":0,"7":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1},"8":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}},"c":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.7320508075688772}},"df":1}}},"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":1}}}}}}}}},"~":{"docs":{},"df":0,"2":{"docs":{},"df":0,"4":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}}}},"1":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":2.6457513110645907},"https://haruband.github.io/delta-cleanup/":{"tf":1.0},"https://haruband.github.io/delta-overview/":{"tf":1.0},"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":2.0},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0},"https://haruband.github.io/k8s-qos-memory/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":16,".":{"docs":{},"df":0,"2":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}},"5":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1},"8":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1,"9":{"docs":{},"df":0,"6":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}},"0":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.7320508075688772},"https://haruband.github.io/delta-checkpoints/":{"tf":2.23606797749979},"https://haruband.github.io/delta-cleanup/":{"tf":1.4142135623730951},"https://haruband.github.io/delta-optimize/":{"tf":1.4142135623730951},"https://haruband.github.io/delta-overview/":{"tf":1.4142135623730951},"https://haruband.github.io/ebpf-core/":{"tf":2.449489742783178},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":11,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,"/":{"docs":{},"df":0,"2":{"docs":{},"df":0,"4":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.4142135623730951}},"df":1}},"8":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.4142135623730951}},"df":1}}},"1":{"docs":{},"df":0,"1":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.7320508075688772}},"df":1}}},"2":{"docs":{},"df":0,"5":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.4142135623730951}},"df":1}}},"3":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":2.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":2,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"4":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":1}}}},"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":1},"7":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":2,":":{"docs":{},"df":0,"8":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":2.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.7320508075688772}},"df":3}}}}}}},"2":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}}}},"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,":":{"docs":{},"df":0,"8":{"docs":{},"df":0,"0":{"docs":{},"df":0,"8":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"8":{"docs":{},"df":0,".":{"docs":{},"df":0,"5":{"docs":{},"df":0,"5":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.7320508075688772}},"df":1}}}}}}},"6":{"docs":{},"df":0,"9":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"3":{"docs":{},"df":0,"6":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.7320508075688772}},"df":1}}}},"4":{"docs":{},"df":0,"9":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"8":{"docs":{},"df":0,"8":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"3":{"docs":{},"df":0,"5":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1,":":{"docs":{},"df":0,"8":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}},"9":{"docs":{},"df":0,"8":{"docs":{},"df":0,".":{"docs":{},"df":0,"3":{"docs":{},"df":0,"6":{"docs":{},"df":0,".":{"docs":{},"df":0,"8":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.4142135623730951}},"df":1,":":{"docs":{},"df":0,"8":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}}}}}}}}}}},"0":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1},"m":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"k":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"0":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"1":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0},"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":5},"2":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":3,"5":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.7320508075688772}},"df":1}}},"8":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1,"m":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}}}},"3":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.4142135623730951}},"df":1},"4":{"docs":{},"df":0,"4":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.0}},"df":1}}},"5":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.0}},"df":1,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1},"8":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951}},"df":1}}}},"6":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0},"https://haruband.github.io/ebpf-core/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.4142135623730951}},"df":3,"&":{"docs":{},"df":0,"n":{"docs":{},"df":0,"b":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}}}}},"0":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.7320508075688772}},"df":1}}},"3":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}}},"9":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{},"df":0,"3":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":2.6457513110645907}},"df":1},"1":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"7":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":2.0}},"df":1,"2":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{},"df":0,".":{"docs":{},"df":0,"5":{"docs":{},"df":0,"2":{"docs":{},"df":0,".":{"docs":{},"df":0,"6":{"docs":{},"df":0,"9":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951}},"df":1,":":{"docs":{},"df":0,"8":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":2.0}},"df":1}}}}}}}}}}},"2":{"docs":{},"df":0,"6":{"docs":{},"df":0,".":{"docs":{},"df":0,"5":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":1,":":{"docs":{},"df":0,"3":{"docs":{},"df":0,"0":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{},"df":0,"5":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":2.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.4142135623730951}},"df":2}}}},"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-nodeport/":{"tf":2.23606797749979}},"df":1}}}}}}},"2":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.4142135623730951}},"df":1}},"8":{"docs":{},"df":0,"0":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-nodeport/":{"tf":2.0}},"df":1}}}}}}}}}}}}}}}}}},"8":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":2,"2":{"docs":{},"df":0,"4":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.7320508075688772}},"df":1}}}},"9":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{},"df":0,"8":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"8":{"docs":{},"df":0,"0":{"docs":{},"df":0,":":{"docs":{},"df":0,"8":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1}}}}}}},"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":2.0}},"df":1,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":3.1622776601683795}},"df":1},"1":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":3.3166247903554}},"df":1}}}}}},"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1},"1":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1},"2":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}},"4":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"9":{"docs":{},"df":0,"8":{"docs":{},"df":0,"/":{"docs":{},"df":0,"0":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}},":":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}},"g":{"docs":{"https://haruband.github.io/k8s-qos-memory/":{"tf":2.0}},"df":1},"~":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1}}},"2":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/delta-checkpoints/":{"tf":1.0},"https://haruband.github.io/delta-cleanup/":{"tf":2.0},"https://haruband.github.io/delta-overview/":{"tf":1.0},"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-qos-memory/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.4142135623730951}},"df":16,".":{"docs":{},"df":0,"4":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1},"5":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}},"0":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":2.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0},"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0}},"df":3,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.0}},"df":1},"6":{"docs":{},"df":0,"/":{"docs":{},"df":0,"0":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1},"3":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}},"7":{"docs":{},"df":0,"/":{"docs":{},"df":0,"0":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}},"8":{"docs":{},"df":0,"/":{"docs":{},"df":0,"0":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}},"~":{"docs":{},"df":0,"3":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}}}}},"1":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/about/":{"tf":1.4142135623730951}},"df":1},"4":{"docs":{},"df":0,"/":{"docs":{},"df":0,"0":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}},"7":{"docs":{},"df":0,"/":{"docs":{},"df":0,"0":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}},"9":{"docs":{},"df":0,"/":{"docs":{},"df":0,"0":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1},"3":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}},"2":{"docs":{},"df":0,"2":{"docs":{},"df":0,"/":{"docs":{},"df":0,"0":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1},"3":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"&":{"docs":{},"df":0,"n":{"docs":{},"df":0,"b":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}}}}}}},"~":{"docs":{},"df":0,"3":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}},"1":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.7320508075688772}},"df":1}}},":":{"docs":{},"df":0,"3":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}},"2":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1},"4":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.4142135623730951}},"df":1},"5":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.4142135623730951}},"df":1,"%":{"docs":{},"df":0,"(":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"6":{"docs":{},"df":0,"5":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}}}}},"6":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}},"~":{"docs":{},"df":0,"3":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.0}},"df":1}}}},"3":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":2.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0}},"df":5,"0":{"docs":{"https://haruband.github.io/delta-optimize/":{"tf":1.0}},"df":1,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"~":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"7":{"docs":{},"df":0,"6":{"docs":{},"df":0,"7":{"docs":{"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0}},"df":1}}}}}}}}},"6":{"docs":{},"df":0,"4":{"docs":{},"df":0,"5":{"docs":{"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0}},"df":1}}}},"2":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.4142135623730951}},"df":2},"4":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.4142135623730951}},"df":1}}},"5":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1},"d":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{},"df":0,"3":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{},"df":0,"0":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,":":{"docs":{},"df":0,"d":{"docs":{},"df":0,"4":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"4":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0},"https://haruband.github.io/delta-checkpoints/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.7320508075688772},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":8,"0":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":2,"%":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{},"df":0,"6":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}}}}},"0":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/delta-cleanup/":{"tf":2.0}},"df":2}},"1":{"docs":{},"df":0,"6":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":1},"7":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":1}},"b":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"6":{"docs":{},"df":0,"0":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"7":{"docs":{},"df":0,"b":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"g":{"docs":{"https://haruband.github.io/k8s-qos-memory/":{"tf":2.23606797749979}},"df":1},"k":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0}},"df":1}}},"5":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0},"https://haruband.github.io/delta-checkpoints/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":3,"0":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":2.0}},"df":1}},"6":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0},"https://haruband.github.io/delta-checkpoints/":{"tf":1.4142135623730951},"https://haruband.github.io/delta-overview/":{"tf":1.4142135623730951},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.7320508075688772},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":6,"4":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":2.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":2.0}},"df":2}},"7":{"docs":{"https://haruband.github.io/delta-optimize/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":3,".":{"docs":{},"df":0,"6":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}},"0":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1},"5":{"docs":{},"df":0,"3":{"docs":{},"df":0,"k":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}}}},"6":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"a":{"docs":{},"df":0,"0":{"docs":{},"df":0,"b":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}},"~":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}}},"8":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":2.0},"https://haruband.github.io/delta-checkpoints/":{"tf":2.0},"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":6,"0":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":2.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2,"8":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1},"2":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0}},"df":1}}}}}}},"4":{"docs":{},"df":0,"7":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":2}}},"g":{"docs":{"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0}},"df":1}},"9":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.4142135623730951}},"df":1,"6":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}},"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}}}}}}}},"a":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1,"(":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0}},"df":1}}}}}}},"c":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0}},"df":2}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1,"(":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}}}}},"d":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.4142135623730951},"https://haruband.github.io/delta-optimize/":{"tf":1.0},"https://haruband.github.io/delta-overview/":{"tf":1.4142135623730951}},"df":3,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}}}},"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":2.0}},"df":1}}}}}}}}}}}},"i":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":3.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":3.0}},"df":4}}}}}}}}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.7320508075688772}},"df":1}}}},"m":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1},"p":{"docs":{"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.7320508075688772}},"df":2},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"w":{"docs":{"https://haruband.github.io/about/":{"tf":1.0},"https://haruband.github.io/datafusion-benchmark/":{"tf":1.4142135623730951},"https://haruband.github.io/datafusion-overview/":{"tf":2.0}},"df":3,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/about/":{"tf":1.0},"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0},"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/datafusion-join/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":5}}}}}}}}}}}},"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":2}}}}}}}}},"v":{"docs":{},"df":0,"g":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1}}}}}}}}},"w":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":2.23606797749979}},"df":1}},"b":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,":":{"docs":{},"df":0,"0":{"docs":{},"df":0,"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"4":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"9":{"docs":{},"df":0,"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"7":{"docs":{},"df":0,"7":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"c":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.4142135623730951}},"df":1}}}},"c":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":4}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0}},"df":1}}}}}}}},"g":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":2.449489742783178}},"df":1}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.7320508075688772}},"df":1}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}}}}},"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":4.242640687119285},"https://haruband.github.io/ebpf-loading-jit/":{"tf":5.0990195135927845},"https://haruband.github.io/ebpf-loading-memory/":{"tf":4.58257569495584},"https://haruband.github.io/ebpf-loading-program/":{"tf":3.1622776601683795},"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":2.6457513110645907},"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":2.8284271247461903},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":4.0},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":3.0},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.4142135623730951}},"df":18,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}},"j":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}},"k":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.4142135623730951}},"df":1}}}}},"p":{"docs":{"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":2.0}},"df":1}}}}}}}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":2.6457513110645907}},"df":1,"0":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.4142135623730951}},"df":1}}},"t":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":2.449489742783178}},"df":1,"(":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951}},"df":1}}}}}},"c":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0},"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":4,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.7320508075688772}},"df":1,"c":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":2.6457513110645907}},"df":3,"(":{"docs":{},"df":0,"+":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":4}}}}}}}},"l":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}},"e":{"docs":{},"df":0,":":{"docs":{},"df":0,"7":{"docs":{},"df":0,"f":{"docs":{},"df":0,":":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,":":{"docs":{},"df":0,"0":{"docs":{},"df":0,"6":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"0":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":4.123105625617661},"https://haruband.github.io/k8s-cni-service/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-qos-memory/":{"tf":2.0},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":6,"v":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":2.0},"https://haruband.github.io/k8s-qos-memory/":{"tf":2.0}},"df":2,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":3.0},"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":3.0},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-service/":{"tf":2.6457513110645907},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":4.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":3.605551275463989},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-networkpolicy/":{"tf":3.1622776601683795},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-rpfilter/":{"tf":2.8284271247461903},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.7320508075688772}},"df":22,"&":{"docs":{},"df":0,"n":{"docs":{},"df":0,"b":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}}},"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{},"df":0,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"#":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.4142135623730951}},"df":4}}}}}}}}}}},"l":{"docs":{},"df":0,"x":{"docs":{},"df":0,"c":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0}},"df":1,"#":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":5}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":4}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"#":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/about/":{"tf":1.4142135623730951}},"df":1}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":2}}}}}}}}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":2.0}},"df":1}}}},"l":{"docs":{},"df":0,"b":{"docs":{},"df":0,"4":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"x":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0}},"df":1}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1}}}}}}}}},"s":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"4":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"v":{"docs":{},"df":0,"x":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":2.8284271247461903}},"df":1}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":2}}}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.4142135623730951}},"df":2}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":2.0},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.4142135623730951}},"df":4}}}}}}}},"m":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":4.69041575982343},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.7320508075688772}},"df":9}},"o":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":2.0}},"df":1,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}}}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/about/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":2.0}},"df":2,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0},"https://haruband.github.io/delta-cleanup/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.0}},"df":1}}}}}}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.7320508075688772}},"df":1}}}},"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-optimize/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":6,"4":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":4}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":2}}},"t":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}}}}}}},"t":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/contact/":{"tf":1.4142135623730951}},"df":1}},"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":5}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":3.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":2.449489742783178}},"df":2}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":2.0},"https://haruband.github.io/datafusion-join/":{"tf":2.0}},"df":2}}}}}},"p":{"docs":{},"df":0,"u":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":3.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951}},"df":5}},"r":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1},"i":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0}},"df":1},"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,"v":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.4142135623730951}},"df":1}}}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":1}}}},"d":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":3.1622776601683795}},"df":1,"0":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.4142135623730951}},"df":1},"1":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":3.1622776601683795}},"df":1},"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/about/":{"tf":1.4142135623730951},"https://haruband.github.io/datafusion-aggregation/":{"tf":2.23606797749979},"https://haruband.github.io/datafusion-benchmark/":{"tf":4.0},"https://haruband.github.io/datafusion-join/":{"tf":1.7320508075688772},"https://haruband.github.io/datafusion-overview/":{"tf":3.605551275463989}},"df":5}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":2.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.4142135623730951}},"df":3,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":2.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":2,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0},"https://haruband.github.io/delta-cleanup/":{"tf":1.0},"https://haruband.github.io/delta-filtering/":{"tf":1.0},"https://haruband.github.io/delta-optimize/":{"tf":1.0},"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":5,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/about/":{"tf":1.7320508075688772},"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.7320508075688772}},"df":1}}}},"v":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.7320508075688772}},"df":1},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":2.23606797749979}},"df":2,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"x":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"5":{"docs":{},"df":0,"5":{"docs":{},"df":0,"4":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"o":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"6":{"docs":{},"df":0,"5":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}}}},"x":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"8":{"docs":{},"df":0,"1":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"d":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.4142135623730951}},"df":3,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-service/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":2.23606797749979}},"df":4,"(":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"j":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.7320508075688772}},"df":1}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":2.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.4142135623730951}},"df":2,"(":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":2}}}}}}}},"t":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.4142135623730951}},"df":1,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.7320508075688772}},"df":1}}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"d":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/about/":{"tf":1.0},"https://haruband.github.io/ebpf-core/":{"tf":1.7320508075688772},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":2.0},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":2.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0}},"df":13}}},"c":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":2.449489742783178}},"df":1}},"d":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1,"x":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":7}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"/":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"/":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"f":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":2}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.7320508075688772}},"df":3,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/datafusion-join/":{"tf":1.0}},"df":2}}}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"/":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1}}}}}},"h":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":2.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":3.4641016151377544},"https://haruband.github.io/k8s-cni-redirect/":{"tf":2.8284271247461903},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":3.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":6,"@":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"4":{"docs":{},"df":0,"1":{"docs":{},"df":0,"7":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":1}}}}}}},"1":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.7320508075688772}},"df":1},"4":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951}},"df":1},"5":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.7320508075688772}},"df":1}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.7320508075688772}},"df":1}}}}}}}},"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.0},"https://haruband.github.io/delta-overview/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":4}}}}}},"t":{"docs":{},"df":0,"3":{"docs":{},"df":0,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}},"4":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"df":0,"4":{"docs":{},"df":0,":":{"docs":{},"df":0,"6":{"docs":{},"df":0,"b":{"docs":{},"df":0,":":{"docs":{},"df":0,"8":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,"8":{"docs":{},"df":0,"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"4":{"docs":{},"df":0,"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}},"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.4142135623730951}},"df":1}},"3":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}},"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}},"d":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.4142135623730951}},"df":1},"i":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.4142135623730951}},"df":1},"l":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.4142135623730951}},"df":1,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.7320508075688772}},"df":1}}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":2.449489742783178}},"df":1}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.4142135623730951},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":2}}}},"l":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"q":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/contact/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}}},"b":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":3.0}},"df":1,"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.7320508075688772}},"df":1}}}},"c":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":2.8284271247461903},"https://haruband.github.io/datafusion-overview/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.4142135623730951}},"df":3,"(":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"p":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.7320508075688772}},"df":1}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"@":{"docs":{},"df":0,"g":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":2.6457513110645907}},"df":1}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.4142135623730951}},"df":1}},"h":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":2.0}},"df":1,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.7320508075688772},"https://haruband.github.io/datafusion-join/":{"tf":1.4142135623730951}},"df":2,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.7320508075688772}},"df":2}}}},"d":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0}},"df":1,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"d":{"docs":{},"df":0,"/":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":3},"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}}}}}},"l":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0}},"df":2}}},"o":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":2},"s":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":3,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.7320508075688772}},"df":5,"/":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":2}}}}}},"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":1},"c":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}},"d":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":2.449489742783178}},"df":1,"(":{"docs":{},"df":0,"8":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"5":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0}},"df":1}}}}}},"c":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1,"3":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":2.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":12,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1}}}}}}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0}},"df":1}}}}}}}}},"o":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.4142135623730951}},"df":1}},"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}},"p":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":3.605551275463989},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":3.1622776601683795},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":3.4641016151377544},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":9,"(":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1}}}}}}}}}}}},"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"d":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":2.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0},"https://haruband.github.io/k8s-networkpolicy/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":8}}}},"v":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":4.898979485566356},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":3}}}}},"r":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":2.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.4142135623730951}},"df":6,"/":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"j":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1}}},"v":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.7320508075688772}},"df":1,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":3.4641016151377544},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":3,"(":{"docs":{},"df":0,"j":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":3,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}}}}}}}}}}}},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.4142135623730951}},"df":1}}}}}}},"o":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":2.0},"https://haruband.github.io/datafusion-join/":{"tf":2.0}},"df":2},"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.4142135623730951},"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":2}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.4142135623730951}},"df":1}}}}}},"p":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":2.0}},"df":2}}}}}}}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1}}}}}}}}},"v":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.4142135623730951},"https://haruband.github.io/datafusion-overview/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":2.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":4,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}}}}}}}}},"k":{"docs":{},"df":0,"6":{"docs":{},"df":0,".":{"docs":{},"df":0,"j":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}},"8":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0},"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":12,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":10}}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":4}}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}}}}}},"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":3}}}},"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.4142135623730951}},"df":1}}}},"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":1}}}},"m":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"v":{"docs":{},"df":0,"f":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":1}}}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/about/":{"tf":1.4142135623730951}},"df":1}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951}},"df":4}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{},"df":0,"y":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}}}}}}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":2}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/about/":{"tf":1.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":2}}}}}},"l":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.7320508075688772}},"df":2,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"3":{"docs":{},"df":0,"/":{"docs":{},"df":0,"u":{"docs":{},"df":0,"d":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":1}}}}}}}},"4":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.4142135623730951}},"df":1},"7":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.7320508075688772}},"df":1},"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}},"d":{"docs":{},"df":0,"x":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"w":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}}}}}}},"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"s":{"docs":{},"df":0,"v":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.4142135623730951}},"df":1}}}}}}},"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":3}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}},"n":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"w":{"docs":{},"df":0,"w":{"docs":{},"df":0,"w":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"h":{"docs":{},"df":0,"y":{"docs":{},"df":0,"e":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951}},"df":2}},"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/delta-optimize/":{"tf":1.0}},"df":1}}}}}}},"l":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":2.23606797749979},"https://haruband.github.io/datafusion-overview/":{"tf":1.7320508075688772}},"df":2}}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":6,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"7":{"docs":{},"df":0,"2":{"docs":{},"df":0,"6":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0}},"df":1}}}},"8":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":2,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1,"(":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0},"https://haruband.github.io/k8s-qos-memory/":{"tf":1.7320508075688772}},"df":2,"(":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"v":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}},"x":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":2.6457513110645907},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":3,"3":{"docs":{},"df":0,"b":{"docs":{},"df":0,"2":{"docs":{},"df":0,"8":{"docs":{},"df":0,"c":{"docs":{},"df":0,"7":{"docs":{},"df":0,"d":{"docs":{},"df":0,"8":{"docs":{},"df":0,"6":{"docs":{},"df":0,"c":{"docs":{},"df":0,"d":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":1}}}}}}}}}}},"c":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{},"df":0,"0":{"docs":{},"df":0,"d":{"docs":{},"df":0,"6":{"docs":{},"df":0,"c":{"docs":{},"df":0,"7":{"docs":{},"df":0,"a":{"docs":{},"df":0,"a":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":2.23606797749979}},"df":1}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.4142135623730951}},"df":1}}}},"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}}},"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0}},"df":1}}}},"p":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":1}}}}},"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}}}}}}}}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.0}},"df":1}}}}}},"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}}},"d":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/about/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.7320508075688772}},"df":3}}}},"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}}}}},"s":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/contact/":{"tf":1.4142135623730951}},"df":1}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":3.3166247903554}},"df":1}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":1,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"b":{"docs":{},"df":0,"/":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"/":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.0}},"df":1}}}}}},"m":{"docs":{},"df":0,"u":{"docs":{"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":1,"d":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.4142135623730951}},"df":1}}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":2.449489742783178}},"df":1}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":2.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":2.6457513110645907}},"df":2}},"b":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.7320508075688772}},"df":2}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"x":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"x":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.4142135623730951}},"df":1,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.4142135623730951}},"df":4}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0}},"df":1,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"x":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":2.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-service/":{"tf":2.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.7320508075688772}},"df":6}}}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0}},"df":5,"0":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":2.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":2.6457513110645907},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":2.449489742783178}},"df":5},"1":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":3.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":2.8284271247461903},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.7320508075688772}},"df":7},"2":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":3.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.7320508075688772}},"df":4},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.4142135623730951}},"df":1}}}}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":2.8284271247461903},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":2.6457513110645907},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":7}}}}}},"n":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":3}}}}}},"v":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}}}},"o":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0}},"df":1,"(":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.0}},"df":1}},"b":{"docs":{},"df":0,"j":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1}}}}}},"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.7320508075688772}},"df":1}},"o":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.4142135623730951},"https://haruband.github.io/datafusion-overview/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0},"https://haruband.github.io/k8s-qos-memory/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":2.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":6,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951}},"df":1}}}}}},"j":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.7320508075688772}},"df":1,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}}}}}}}}}}}},"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"j":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}}}}}}}}},"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"/":{"docs":{},"df":0,"g":{"docs":{},"df":0,"b":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"j":{"docs":{},"df":0,"d":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.4142135623730951}},"df":1}}}}},"t":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0}},"df":1,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/delta-optimize/":{"tf":1.0},"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0}},"df":2}}}},"u":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":2}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":2,"f":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}}}}}}},"p":{"docs":{},"df":0,"9":{"docs":{},"df":0,"9":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}},"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.4142135623730951},"https://haruband.github.io/delta-checkpoints/":{"tf":1.0},"https://haruband.github.io/delta-filtering/":{"tf":1.4142135623730951},"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":4,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.7320508075688772}},"df":1}}}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.0},"https://haruband.github.io/delta-filtering/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}},"s":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.7320508075688772}},"df":1}},"t":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":2}},"r":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.4142135623730951}},"df":2}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{},"df":0,"5":{"docs":{},"df":0,"6":{"docs":{},"df":0,"6":{"docs":{},"df":0,"7":{"docs":{},"df":0,"5":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":1}}}}}}}},"x":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":2.0},"https://haruband.github.io/k8s-cni-redirect/":{"tf":2.6457513110645907},"https://haruband.github.io/k8s-cni-service/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":2.0}},"df":4,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":1}}}}}}},"0":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":2.8284271247461903},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":5,"&":{"docs":{},"df":0,"n":{"docs":{},"df":0,"b":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0}},"df":1}}}}}},"1":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":5},"2":{"docs":{"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.4142135623730951}},"df":1},"3":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":5},"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":2}}}},"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"q":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}},"r":{"docs":{"https://haruband.github.io/delta-optimize/":{"tf":1.0}},"df":1,"e":{"docs":{"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0}},"df":1,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0}},"df":1}}}},"v":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.7320508075688772}},"df":1}},"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.4142135623730951}},"df":1}}}},"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":2.23606797749979}},"df":2}}}}}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1,"/":{"docs":{},"df":0,"j":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}}}}}}},"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.4142135623730951}},"df":1}}}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":1}}}},"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0}},"df":1}}}}},"x":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.4142135623730951}},"df":1}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.4142135623730951}},"df":1}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.4142135623730951}},"df":1}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}}}}}}}},"q":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1,"2":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}},"6":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1},"o":{"docs":{"https://haruband.github.io/k8s-memory-swap/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-qos-memory/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951}},"df":3}},"r":{"docs":{},"df":0,"1":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.4142135623730951},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":2},"2":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.4142135623730951}},"df":2},"3":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1},"7":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1},"d":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":2.0}},"df":1}},"e":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.4142135623730951}},"df":1,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.4142135623730951}},"df":1}}}}}}},"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}},"d":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1,"i":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":1}}}}}}}}}}}},"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}}}}}},"v":{"docs":{},"df":0,"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1,"4":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":5}}}}}},"g":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1,"2":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":2}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1},"v":{"docs":{"https://haruband.github.io/delta-optimize/":{"tf":1.0},"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"q":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":2}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"s":{"docs":{},"df":0,"v":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":2.23606797749979}},"df":1,"0":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.4142135623730951}},"df":1}}}}},"u":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":2.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":2.23606797749979}},"df":3}},"w":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.4142135623730951},"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":2}},"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.4142135623730951}},"df":1,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":3.4641016151377544},"https://haruband.github.io/k8s-rpfilter/":{"tf":3.605551275463989}},"df":2}}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":1},"s":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.4142135623730951}},"df":1,"(":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}}}}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.4142135623730951}},"df":1}},"n":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.7320508075688772}},"df":1,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"v":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":2.0}},"df":1}}}}}}}}}}}}}}}},"=":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"x":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.4142135623730951}},"df":1}}}}}},"q":{"docs":{},"df":0,"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.4142135623730951},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":2}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/about/":{"tf":1.0},"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":4}}},"x":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/about/":{"tf":1.0},"https://haruband.github.io/delta-optimize/":{"tf":1.0}},"df":2},"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0},"https://haruband.github.io/delta-filtering/":{"tf":1.7320508075688772}},"df":2}}},"e":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":2}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"n":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/contact/":{"tf":1.4142135623730951}},"df":1,"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"g":{"docs":{},"df":0,"4":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":2}}}},"r":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":3}},"i":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":2.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":1}}}}}}}}}}}},"t":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}},"f":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":1}}}}},"z":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.4142135623730951}},"df":1}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}},"n":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":2.6457513110645907}},"df":4,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}}}}}}}}},"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":2}}}},"o":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.4142135623730951}},"df":1}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.4142135623730951},"https://haruband.github.io/datafusion-join/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":2.23606797749979}},"df":1}}}}}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":2}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":4.0},"https://haruband.github.io/datafusion-join/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":5,".":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0}},"df":1}}}},"q":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.4142135623730951},"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/datafusion-join/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":2.23606797749979}},"df":4}},"r":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.4142135623730951}},"df":1,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}}}},"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.7320508075688772}},"df":1}}}}},"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":1,"/":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":3.1622776601683795}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"z":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}}}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/about/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":3,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.4142135623730951}},"df":2}}},"p":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}},"y":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}}}}},"t":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.7320508075688772}},"df":1}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1,"d":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.7320508075688772}},"df":1}}}}}}},"t":{"docs":{"https://haruband.github.io/about/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.4142135623730951}},"df":1}}}}}}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":2.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":2}}}}},"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0}},"df":1}}}}}}}}}}},"s":{"docs":{},"df":0,"k":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"(":{"docs":{},"df":0,"0":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":3.0}},"df":1}}}}}}}}}},"c":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":2,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":4}}}}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":3.0}},"df":1}}},"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}},"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":4}}},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.7320508075688772}},"df":1}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"t":{"docs":{},"df":0,"f":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}},"c":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":2.0}},"df":1},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.4142135623730951}},"df":1}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}},"s":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.4142135623730951}},"df":2}}}}},"x":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0}},"df":1},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"https://haruband.github.io/k8s-rpfilter/":{"tf":1.4142135623730951}},"df":1}},"p":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":2.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":2.23606797749979}},"df":2}},"i":{"docs":{},"df":0,"/":{"docs":{},"df":0,"u":{"docs":{},"df":0,"x":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":2.0}},"df":1},"l":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1}},"s":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.4142135623730951}},"df":1,"+":{"docs":{},"df":0,"9":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/delta-optimize/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.7320508075688772},"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-redirect/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":2.0},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":7,"/":{"docs":{},"df":0,"v":{"docs":{},"df":0,"x":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0}},"df":1}}}}}},"0":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":6},"1":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":2.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.4142135623730951}},"df":4},"4":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":2.23606797749979}},"df":1},"5":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.7320508075688772}},"df":1}}}},"f":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":1}}}}}}}}}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1},"x":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":2.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.7320508075688772},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":3.872983346207417},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":2.6457513110645907}},"df":6,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"x":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"5":{"docs":{},"df":0,"4":{"docs":{},"df":0,"2":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"o":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{},"df":0,"6":{"docs":{},"df":0,"3":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}}}},"x":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"8":{"docs":{},"df":0,"9":{"docs":{},"df":0,"6":{"docs":{"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}},"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/about/":{"tf":1.4142135623730951}},"df":1}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":2.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.7320508075688772}},"df":3}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}}}}},"l":{"docs":{},"df":0,"d":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":2.0}},"df":1}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0}},"df":1,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/k8s-qos-memory/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.4142135623730951},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":3}}}}}}}}},"x":{"docs":{},"df":0,"1":{"docs":{},"df":0,"~":{"docs":{},"df":0,"x":{"docs":{},"df":0,"9":{"docs":{},"df":0,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":1}}}}}}}}},"8":{"docs":{},"df":0,"6":{"docs":{"https://haruband.github.io/datafusion-overview/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":4.358898943540674},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.4142135623730951},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0},"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0}},"df":5,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"/":{"docs":{},"df":0,"k":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/about/":{"tf":1.0}},"df":1}}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":2.449489742783178}},"df":1}},"x":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}}},"y":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.7320508075688772}},"df":1,"=":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"/":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"=":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/delta-filtering/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}},"z":{"docs":{"https://haruband.github.io/delta-optimize/":{"tf":1.0}},"df":1,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":2.23606797749979},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":2.449489742783178},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":3.3166247903554}},"df":4,"0":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1},"2":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0}},"df":1}}}}}}}}}},"description":{"root":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":4}}}}}}}}}},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0},"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/datafusion-join/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":4}}}}}}}}}}}}},"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":3,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"c":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"v":{"docs":{},"df":0,"2":{"docs":{},"df":0,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":6}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/contact/":{"tf":1.4142135623730951}},"df":1}}}}}}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":2}}}}}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0},"https://haruband.github.io/delta-cleanup/":{"tf":1.0},"https://haruband.github.io/delta-filtering/":{"tf":1.0},"https://haruband.github.io/delta-optimize/":{"tf":1.0},"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":5}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":5}}},"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}}}}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"v":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}}},"j":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.0}},"df":1}}}},"k":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0},"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0},"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":10,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":10}}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":4}}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}}}}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":2}}}}}}}}},"r":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0}},"df":1}}}}}}}}}}}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0}},"df":2}}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1}}}}},"q":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":2}}}}}}},"u":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":2}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":1}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}},"v":{"docs":{},"df":0,"x":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":2}}}}}}},"title":{"root":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":4}}}}}}}}}},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"https://haruband.github.io/datafusion-aggregation/":{"tf":1.0},"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0},"https://haruband.github.io/datafusion-join/":{"tf":1.0},"https://haruband.github.io/datafusion-overview/":{"tf":1.0}},"df":4}}}}}}}}}}}}},"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0}},"df":3,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"c":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"v":{"docs":{},"df":0,"2":{"docs":{},"df":0,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":6}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/delta-cleanup/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-cni-service/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/contact/":{"tf":1.0}},"df":1}}}}}}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":2}}}}}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"https://haruband.github.io/delta-checkpoints/":{"tf":1.0},"https://haruband.github.io/delta-cleanup/":{"tf":1.0},"https://haruband.github.io/delta-filtering/":{"tf":1.0},"https://haruband.github.io/delta-optimize/":{"tf":1.0},"https://haruband.github.io/delta-overview/":{"tf":1.0}},"df":5}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,"f":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-memory/":{"tf":1.0},"https://haruband.github.io/ebpf-loading-program/":{"tf":1.0},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":5}}},"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"v":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":1}}}}},"j":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/ebpf-loading-jit/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/datafusion-join/":{"tf":1.0}},"df":1}}}},"k":{"docs":{},"df":0,"8":{"docs":{"https://haruband.github.io/k8s-cgroupv2-privatens/":{"tf":1.0},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0},"https://haruband.github.io/k8s-memory-swap/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0},"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0},"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":10,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0},"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0},"https://haruband.github.io/k8s-cni-redirect/":{"tf":1.0},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"tf":1.0},"https://haruband.github.io/k8s-cni-service/":{"tf":1.0},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0},"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":10}}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-istio-ambientmesh/":{"tf":1.0}},"df":4}}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0},"https://haruband.github.io/k8s-spark-optimize/":{"tf":1.0}},"df":2}}}}}}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":2}}}}}}}}},"r":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"b":{"docs":{"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-nat-loopback-lrp/":{"tf":1.0},"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-networkpolicy/":{"tf":1.0}},"df":1}}}}}}}}}}}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"tf":1.0},"https://haruband.github.io/k8s-cni-nodeport/":{"tf":1.0}},"df":2}}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{},"df":0,"i":{"docs":{"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"tf":1.0}},"df":1}}}}},"q":{"docs":{},"df":0,"o":{"docs":{"https://haruband.github.io/k8s-qos-memory/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-ipvlan/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"tf":1.0},"https://haruband.github.io/k8s-rpfilter/":{"tf":1.0}},"df":2}}}}}}},"u":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/ebpf-core/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"https://haruband.github.io/k8s-cni-dsr/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-nat-loopback-snat/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"https://haruband.github.io/k8s-cni-loadbalancing/":{"tf":1.0},"https://haruband.github.io/k8s-proxy-bypass/":{"tf":1.0}},"df":2}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"https://haruband.github.io/datafusion-benchmark/":{"tf":1.0}},"df":1}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"https://haruband.github.io/k8s-spark-optimize-swap/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0}},"df":1}}}}}},"v":{"docs":{},"df":0,"x":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"https://haruband.github.io/k8s-cni-vxlan/":{"tf":1.0},"https://haruband.github.io/k8s-vxlan-forbidden/":{"tf":1.0}},"df":2}}}}}}}},"documentStore":{"save":true,"docs":{"https://haruband.github.io/":{"body":"","description":"","id":"https://haruband.github.io/","title":""},"https://haruband.github.io/about/":{"body":"잉클 (DataOps/DevOps/CTO, 2022/03 ~)\n\n실시간 빅데이터 엔진 개발 (Arrow, Datafusion, ...)\n\nRust 기반 고성능 쿼리 엔진 개발 및 최적화 (Datafusion)\n스토리지 엔진 최적화 (DeltaLake, ...)\n다양한 프로토콜 지원 (FlightSQL, PostgreSQL, RestSQL)\nOPA 기반 접근 제어\n\n\n레이크하우스 아키텍처 설계 및 개발 (DeltaLake, Iceberg)\n실시간 AI 추론 플랫폼 개발\n\n시계열 데이터 추론 (Arrow/Datafusion, ...)\n이미지 추론 (S3, ...)\n\n\n쿠버네티스 클러스터 구축 및 최적화\n\nKubeadm 을 이용한 쿠버네티스 클러스터 구축 (Ansible)\n메모리, 네트워킹 및 스토리지 최적화 (Cilium/eBPF, ...)\n\n\n\n바텍 (SRE/DevOps/DataOps/MLOps, 2019/03 ~ 2022/02)\n\n쿠버네티스 클러스터 구축\n\nKubeadm 을 이용한 쿠버네티스 클러스터 구축\nKustomization 기반 IaC(Infrastructure as Code) 구축\n\n\n쿠버네티스 클러스터 최적화\n\n네트워킹 최적화 (Cilium/eBPF, ...)\n스토리지 최적화 (LocalPersistentVolume with HDD/SSD/NVMe, ...)\n메모리 최적화 (swapping, ...)\n\n\n쿠버네티스 클러스터 모니터링\n\nElastic 솔루션 (ElasticSearch/Kibana/Filebeat/Metricbeat/Heartbeat/ApmServer)\nDatadog 솔루션\n\n\n데이터 엔지니어링\n\nDeltaLake 기반 LakeHouse 아키텍처 설계 및 개발\nMinio/Mongodb/ElasticSearch/Kafka/Spark/Airflow/...\n\n\n\n성균관대학교 (석사/박사, 2008/03 ~ 2019/02)\n\n쿠버네티스 연구/개발\n\n네트워킹/스토리지/메모리 관리 연구\n\n\n리눅스 커널 연구/개발\n\n메모리 관리 연구/개발 (swapping, non-volatile memory, ...)\n고속 네트워킹 연구/개발 (eBPF, 인터럽트 최적화, ...)\n파일시스템 및 블록 드라이버 연구/개발 (ext3/btrfs, overlayfs, lvm, ...)\n\n\n가상화/컨테이너 엔진 연구/개발\n\n리눅스 커널 기반 가상화 엔진 개발\nIntel VT 기반 가상화 엔진 개발 (하드웨어 지원 가상화 및 반가상화 기술의 장점 활용)\n모바일 가상화 엔진 개발 (안드로이드 모바일 플랫폼에 적용, 2010년 대한민국 소프트웨어 공모대전에서 국무총리상 수상)\n가상화 기반 파일시스템 개발 (호스트와 게스트 간의 시맨틱갭을 제거하는 것이 목적)\n\n\nXen/KVM 기반 게스트 프로세스 동적 분석기 개발\n\n보안 관련 연구소 의뢰로 가상머신 안에서 악성코드 분석을 위해 개발\n\n\n\n네모유엑스 (CEO/CTO, 2014/08 ~ 2017/08)\n\n다중 사용자 지원 UI/UX 소프트웨어 플랫폼 개발\n\nOpenGLES/EGL/DRM/GBM 기반 컴포지팅 엔진 개발\nWayland 기반 다중 사용자 지원 윈도우 매니저 개발\nWayland 기반 3D 윈도우 매니저 개발\n\n\n\nMDS 테크놀러지 (2006/03 ~ 2007/08)\n\nT-DMB/ISDB-T 풀스택 개발\n\n리눅스 부트로더 포팅 및 최적화\n리눅스 커널 포팅 및 최적화\nDMB 풀스택 개발 (MPEG-TS)\n\n\n\n성균관대학교 (학사, 1998/03 ~ 2006/02)\n\n운영체제/가상화 연구/개발\n\nx86/ARM 기반 커널 개발\n리눅스 커널 분석 및 개발\n리눅스 커널 기반 가상화 엔진 개발\n\n\n\n수상 실적\n대한민국 소프트웨어 공모대전 국무총리상(금상) (2010)\n\n안드로이드를 위한 모바일 가상화 엔진 개발\n\n하나의 기기에서 두 개의 안드로이드 실행 가능\n리눅스 커널 기반 가상화 엔진 자체 개발\n\n\n\nSNS\nSNSLink\nGmailharuband@gmail.com\nCodeBookhttps://haruband.github.io\nNemoUXhttps://nemoux00.wordpress.com/\nLinkedInhttps://www.linkedin.com/in/inhyeok-kim-7620a0b0/\n\n","description":"","id":"https://haruband.github.io/about/","title":"About"},"https://haruband.github.io/archive/":{"body":"","description":"","id":"https://haruband.github.io/archive/","title":""},"https://haruband.github.io/blog/":{"body":"","description":"","id":"https://haruband.github.io/blog/","title":""},"https://haruband.github.io/contact/":{"body":"Want to get in touch? Fill out the form below to send me a message and I will get back to you as soon as possible!\n\n  \n    Name\n    \n  \n  \n    Email Address\n    \n  \n  \n    Message\n    \n  \n  \n  \n    Send\n  \n\n","description":"To reach us please use the contact form on this page.","id":"https://haruband.github.io/contact/","title":"Contact"},"https://haruband.github.io/datafusion-aggregation/":{"body":"데이터를 분석할 때 가장 많이 사용하는 기능은 집계일 것이다. 특히, 시계열 데이터를 분석할 때는 시간대별 통계를 자주 사용하기 때문에 무엇보다 집계의 성능이 중요하다. 그래서 오늘은 Datafusion 에서 이러한 집계가 어떤 과정으로 이루어지는지, 그리고 어떤 방법으로 최적화되는지 살펴보도록 하자.\n간단한 집계를 위한 SQL 쿼리를 실행해보자. 아래는 국가별/직업별 최소 수입과 평균 수입을 구하는 쿼리이다.\n\n위의 쿼리는 아래와 같은 논리 계획으로 변환된다.\n\n위의 논리 계획은 테이블에서 세 개의 컬럼[country, job, salary]을 읽어서 두 개의 컬럼[country, job]으로 그룹핑(grouping)한 다음, 그룹별 최소 수입[min(salary)]과 평균 수입[avg(salary)]을 구하는 것이다. 위의 논리 계획은 아래와 같은 실행 계획으로 변환된다.\n\n위의 실행 계획은 데이터(CSV) 파일을 읽는 CsvExec 실행 계획과 모든 입력을 받아서 집계를 구하는 AggregateExec 실행 계획으로 구성되어 있다. AggregateExec 실행 계획에서 집계를 구하는 방식은 아래 그림처럼 전달받은 모든 데이터를 그룹핑한 후 최소 수입과 평균 수입을 계산하는 것이다.\n\n위의 실행 계획은 어떤 문제를 가지고 있을까? 입력 데이터의 크기가 커지면 하나의 파티션에서 모든 작업을 처리하는 것은 굉장히 오래 걸릴 것이다. 그렇다면 이를 나누어서 처리할 수 있는 방법은 없을까? 이를 해결하기 위해 Datafusion 은 최종 집계를 구하기 전에 부분 집계를 구하는 방식을 제공하고 있다. (대부분의 SQL 엔진이 비슷한 기능을 제공하고 있다.) 아래는 두 개의 파티션을 사용하도록 설정했을 때의 실행 계획이다.\n\n위의 실행 계획은 데이터 파일을 읽어서(CsvExec) 라운드로빈 방식으로 두 개의 파티션으로 나눈 다음(RepartitionExec) 각각 부분 집계를 구하고(AggregateExec), 이를 하나의 파티션으로 합친 다음(CoalescePartitionsExec) 최종 집계를 구한다(AggregateExec). 아래 그림을 보면 중간에 부분 집계가 추가된 것을 볼 수 있다. (최소값의 부분 집계는 최소값이지만, 평균값의 부분 집계는 합과 개수이고 최종 집계에서 합을 개수로 나누어서 평균값을 구한다.)\n\n위의 실행 계획은 어떤 문제를 가지고 있을까? 부분 집계를 병렬로 구하는 것은 좋지만, 최종 집계를 하나의 파티션으로 처리하는 것은 아쉬워보인다. Datafusion 에서 이를 어떻게 개선하는지 아래 실행 계획을 보면서 분석해보자.\n\n위의 실행 계획을 보면, 두 개의 파티션으로 부분 집계를 구하는 것까진 동일하다. 하지만 그룹 컬럼[country, job]의 해시를 이용하여 파티션이 재분배되는 부분이 추가되었고, 이를 통해 다른 파티션에 존재하는 같은 그룹[country, job]의 부분 집계를 하나의 파티션으로 모아서 최종 집계를 구할 수 있게 된다. 아래 그림을 보면, 다른 파티션에서 부분 집계를 구한 그룹(japan, sales)이 최종 집계를 구할때는 하나의 파티션으로 모인 것을 볼 수 있다.\n\n이렇게 부분 집계를 구한 다음 최종 집계를 구하는 것이 항상 좋은 성능을 보여줄까? 그렇지는 않다. 위의 예제를 보더라도, 입력값의 개수는 6 개인데, 부분 집계가 5 개이고 최종 집계가 4 개이다. 이런 경우라면 부분 집계를 구하지 않고 바로 최종 집계를 구하는 것이 좋지 않을까? 어떤 방식이 좋을지는 입력 데이터에 굉장히 의존적이기 때문에 Datafusion 에서는 부분 집계를 구하는 동안 주기적으로 여러 가지 상황을 체크해서 부분 집계를 구하는 것을 중단할지 판단한다. 예를 들어 그룹의 개수와 입력값의 개수를 비교하여 일정 비율이 넘으면 부분 집계를 중단시키는 것이 가능하다. (그룹의 개수가 많아질수록 그룹당 하나씩 생성되는 Accumulator 가 많아지는데 그룹당 누산되는 입력값의 개수가 적어지면 효율이 굉장히 떨어진다.)\n스트리밍 데이터에 대한 집계를 구하는 것도 가능한데, 일반적인 집계는 사용할 수 없고 부분 혹은 전체 정렬된 그룹에 대해서만 집계를 구할 수 있다. 데이터가 끝없이 들어오더라도 그룹이 정렬되어 있다면 다음 그룹이 들어오기 시작할때부터는 이전 그룹은 더 이상 새로운 입력값이 들어오지 않는 것이 보장되기 때문이다. 일반적으로 스트리밍 데이터는 시간 순서로 정렬된 경우가 많기 때문에 대부분의 경우 어렵지 않게 집계를 구할 수 있다.\n지금까지 Datafusion 이 집계를 어떻게 구하는지 살펴보았다. 이외에도 다양한 기능들을 제공하고 있으니 본인이 다루고 있는 데이터의 특성과 환경에 맞게 설정해서 사용한다면 굉장히 만족스러운 결과를 얻을 수 있을 것으로 기대된다.\n","description":"","id":"https://haruband.github.io/datafusion-aggregation/","title":"[Arrow/Datafusion] 동작 과정 분석 (Aggregation)"},"https://haruband.github.io/datafusion-benchmark/":{"body":"Datafusion 은 Arrow 를 이용하여 Rust 기반으로 개발 중인 임베딩 SQL 엔진이다. 그래서 Scala 기반으로 개발되어 JVM 위에서 동작하는 Spark 에 비해 아래와 같은 장점을 가진다.\n\nGC 없이 메모리 안정성 보장\n컬럼 기반 데이터 포맷 사용 (Arrow)\nLLVM 기반 최적화 (Vectorization, ...)\n\n그렇다면 이러한 장점들이 실제 성능에는 얼마나 영향을 주는지 알아보도록 하자. 오늘은 단일 머신에서의 성능만을 비교하고, 추후에 Ballista 와 같은 Datafusion 기반의 분산 처리 기술을 이용하여 분산 처리 성능도 비교해보도록 하겠다.\n실험은 OLAP 성능 검증을 위해 자주 사용되는 TPC-H (SF1000) 를 이용하였다. 실험 결과는 처리 시간과 메모리 사용량을 이용하여 분석하였으며, 최대 메모리 사용량(JVM)에 영향을 많이 받는 Spark 는 8 ~ 64 GB 까지 최대 메모리 사용량을 변경해가면서 성능을 측정하였다.\n첫 번째 실험은 하나의 테이블에서 몇 가지 조건절을 이용하여 데이터를 필터링한 다음 합계를 구하는 쿼리(TPC-H-Q6)이다.\n\n아래는 처리 시간을 보여주고 있다. Datafusion 이 Spark 에 비해 대략 10 배 정도 좋은 성능을 보여주고 있다.\n\n아래는 실제 메모리 사용량을 측정한 결과이다. Datafusion 은 최대 1.8 GB 정도의 메모리를 사용하였으며, Spark 는 최대 메모리 사용량(-Xmx)이 클수록 실제 메모리 사용량이 커지면서 오히려 성능이 약간 떨어지는 모습을 볼 수 있다. Spark 는 중간 결과나 재활용할 수 있는 데이터를 메모리에 최대한 유지하는 정책을 취하기 때문에 메모리 사용량이 증가하면서 GC(GarbageCollection) 오버헤드를 증가시키는 등 오히려 안 좋은 결과를 보여줄 수 있다. (최대 메모리 사용량이 8 GB 일때는 GC 에 1.5 초를 소요했지만, 64 GB 일때는 2.4 초를 소요했다.)\n\n두 번째 실험은 하나의 테이블에서 그룹별 집계를 구하는 쿼리(TPC-H-Q1)이다.\n\nDatafusion 이 Spark 에 비해 대략 10 ~ 12 배 정도 좋은 성능을 보여주고 있다.\n\nDatafusion 은 최대 2 GB 정도의 메모리를 사용하였으며, Spark 는 앞의 실험과 유사한 결과를 보여주지만 그룹별 집계가 메모리 사용량이 많기 때문에 성능이 나빠지는 정도가 훨씬 심해진 것을 볼 수 있다. (최대 메모리 사용량이 8 GB 일때는 GC 에 21 초를 소요했지만, 64 GB 일때는 40 초를 소요했다.)\n\n세 번째 실험은 두 개의 테이블을 조인하는 쿼리(TPC-H-Q12)이다. 등가(Equal) 조인을 처리하는 방식은 BroadcastJoin, HashJoin, SortMergeJoin 등이 있는데, 이번 실험에서는 최적화가 충분치 않은 Datafusion 의 SortMergeJoin 과 데이터 크기가 커서 사용할 수 없는 Spark 의 BroadcastJoin 은 제외하고 진행하였다.\n\nDatafusion 의 BroadcastJoin 이 가장 좋은 성능을 보여주고 있으며, Spark 에 비해 대략 7.6 배 정도 좋은 성능을 보여주고 있다.\n\nDatafusion 은 BroadcastJoin 과 HashJoin 에서 2.5 GB 정도의 메모리를 사용하였으며, Spark 는 HashJoin 에서 64 GB 의 메모리도 부족하여 파티션을 두 배(400)로 늘려서 실험하였다.\n\n실험 결과를 종합해보면, Datafusion 이 훨씬 적은 메모리를 사용하면서도 10 배 정도 좋은 성능을 보여주고 있다. 또한, Spark 는 최대 메모리 사용량에 따른 실제 메모리 사용량과 처리 시간을 예측하기 힘들고, 최대 메모리 사용량이 부족하면 예기치 못한 OOM(OutOfMemory) 도 자주 발생하기 때문에 사용하기가 매우 까다롭다.\n마지막으로 Datafusion 이 어떻게 좋은 성능을 보여주는지 살펴보도록 하자.\n첫 번째 이유는 GC 를 사용하지 않기 때문이다. GC 를 사용하면 메모리를 반환하더라도 GC 에 의해 해제되기 전까지 재사용이 불가능하기 때문에 실제 메모리 사용량보다 많은 메모리를 사용할 수 밖에 없고, 실제 메모리 사용량을 정확히 예측하기 어렵다. 그리고 최대 메모리 사용량을 늘리면 GC 에 의해 관리되는 영역이 커지기 때문에 그만큼 오버헤드가 증가하지만, 최대 메모리 사용량을 줄이면 예기치 못한 OOM 이 발생한다. 반면에, GC 를 사용하지 않고 시스템 메모리를 바로 사용하면 메모리를 반환하는 즉시 재사용이 가능하고, 최대 메모리 사용량을 별도로 설정할 필요없이 시스템 메모리를 최대로 활용할 수 있으며 스왑까지 충분히 활용한다면 이론적으로는 OOM 은 발생하지 않는다.\n두 번째 이유는 컬럼 기반 데이터 포맷을 사용하기 때문이다. 이로 인해 캐시 효율이 높아지고, 아래 소개할 LLVM 을 이용한 AutoVectorization 도 가능해진다.\n세 번째 이유는 LLVM 을 이용하여 최적화하기 때문이다. Spark 는 바이트코드로 배포되어 JIT(JustInTime) 기술을 이용하여 실행되기 때문에 충분한 최적화를 하기가 힘들지만, Datafusion 은 LLVM 으로 컴파일한 네이티브코드를 배포하기 때문에 충분한 최적화를 할 수 있다. 이로 인해 컬럼 기반 데이터 포맷을 사용하는 Datafusion 에서는 각각의 컬럼이 연속된 메모리 공간을 차지하기 때문에 최소한의 노력으로 Vectorization 과 같은 하드웨어 가속을 바로 사용할 수 있게 된다.\n8 개 정수의 합을 구하는 간단한 예제를 통해 LLVM 이 어떻게 연속된 메모리에 대한 반복 연산을 최적화하는지 살펴보자.\n\n아래는 위의 코드를 최적화 없이 컴파일한 결과이다. 많은 명령어와 메모리 접근이 빈번하게 발생하는 것을 볼 수 있다.\n\n아래는 Vectorization 이 적용된 결과이다. 위의 코드에 비해 훨씬 적은 명령어와 메모리 접근이 발생하는 것을 볼 수 있다.\n\n지금까지 몇 가지 실험을 통해 Datafusion 과 Spark 의 성능을 검증 및 분석해보았다. Datafusion 은 아직 공개된지 오래되지 않았고, 매우 활발하게 개발 중이기 때문에 앞으로 더 좋은 성능을 보여줄 것으로 기대하고 있다. 그리고 Spark 와 Trino 도 자바의 한계를 벗어나기 위해 핵심 쿼리 엔진을 Photon 이나 Velox 로 교체하려는 시도를 하고 있고, Spark 의 쿼리 엔진을 Datafusion 으로 교체하려는 시도도 이미 진행 중이기 때문에 앞으로 많은 변화가 있을 것으로 기대된다.\n","description":"","id":"https://haruband.github.io/datafusion-benchmark/","title":"[Arrow/Datafusion] 성능 평가 (Spark)"},"https://haruband.github.io/datafusion-join/":{"body":"대부분의 SQL 엔진에서 성능 향상을 위해 가장 많이 신경쓰는 부분은 바로 조인(Join)일 것이다. 그래서 다양한 조건의 조인을 처리하는 여러 가지 동작 방식이 존재하고, 다양한 상황을 고려하여 최선의 동작 방식을 선택하는 것이 필수이다. 오늘은 Datafusion 에서 어떤 방식으로 조인을 처리하는지, 어떤 방법으로 최적화되는지 살펴보도록 하자.\n조인을 처리하는 방식에 가장 큰 영향을 주는 등가(Equal) 조건의 유무에 따라 조인을 어떻게 처리하는지 살펴보자.\n\n위의 쿼리는 두 개 컬럼[country, job]에 대한 등가 조건을 포함하고 있고, 아래와 같은 논리 계획으로 변환되어 일반적으로 두 가지 방식(HashJoin/SortMergeJoin)으로 실행된다.\n\n우선, 대부분 가장 좋은 성능을 보여주는 HashJoin 부터 살펴보자. 이는 아래 그림처럼 작은 테이블을 이용하여 해시 테이블을 먼저 만들고, 큰 테이블을 순서대로 비교하면서 처리하는 방식이다. 해시를 이용하기 때문에 큰 테이블에 있는 데이터가 작은 테이블에 있는지 비교하는 비용은 O(1) 이지만, 해시 테이블을 메모리에 유지하는 비용이 문제가 될 수 있다. 그래서 테이블의 크기가 작다면 하나의 해시 테이블을 만드는 방식(CollectLeft)을 사용하고, 테이블의 크기가 크다면 조건 컬럼[country, job]의 해시를 이용해서 나눈 다음 파티션별로 해시 테이블을 만드는 방식(Partitioned)을 사용한다.\n\n조인에 사용되는 두 개의 테이블 중에 크기가 충분히 작은 테이블이 있다면 아래와 같은 실행 계획으로 변환된다.\n\n위의 실행 계획은 작은 테이블(left.csv)을 이용하여 해시 테이블을 먼저 만들고, 큰 테이블(right.csv)은 두 개의 파티션으로 나눈 다음 앞에서 만든 해시 테이블을 이용하여 비교한다. 분산 처리 엔진(Spark)은 마스터 노드에서 해시 테이블을 만들어서 워커 노드로 전송하기 때문에 오버헤드가 크지만, Datafusion 은 하나의 프로세스 내에서 간단히 해시 테이블을 공유해서 사용한다.\n조인에 사용되는 두 개의 테이블 중에 크기가 충분히 작은 테이블이 없다면 아래와 같은 실행 계획으로 변환된다.\n\n위의 실행 계획은 두 테이블을 각각 두 개의 파티션으로 나눈 다음, 조건 컬럼[country, job]의 해시를 이용하여 파티션을 재분배한다. 이렇게 되면 같은 조건 컬럼을 가지는 두 테이블의 모든 행(row)은 같은 파티션으로 모이기 때문에 파티션별로 해시 테이블을 만들어서 처리하면 된다.\n다음으로, SortMergeJoin 을 살펴보자. 이는 아래 그림처럼 두 개의 테이블을 정렬한 다음 순차적으로 비교하면서 처리하는 방식이다. 정렬된 두 개의 테이블이 어떤 순서로 처리되는지 번호로 표시를 해두었다. 원리는 단순한데, 두 개의 테이블을 비교해서 오른쪽 테이블의 행(row)이 크면 왼쪽 테이블의 다음 행으로 넘어가고, 왼쪽 테이블의 행이 크면 오른쪽 테이블의 다음 행으로 넘어간다. 이런 방식으로 하면 빠짐없이 같은 조건 컬럼을 가지는 모든 행의 조합을 찾을 수 있다.\n\nSortMergeJoin 을 사용했을 때의 실행 계획은 아래와 같다.\n\n위의 실행 계획은 두 테이블을 각각 두 개의 파티션으로 나눈 다음, 조건 컬럼[country, job]의 해시를 이용하여 파티션을 재분배한다. 그리고 파티션별로 정렬한 다음 순차적으로 비교하면서 처리한다.\n아래와 같이 등가 조건이 없는 비등가 조인은 어떻게 처리되는지 살펴보자.\n\n위의 쿼리는 아래와 같은 논리 계획으로 변환된다.\n\n비등가 조인은 일반적으로 두 가지 방식(NestedLoopJoin/CrossJoin)으로 처리된다. 동작 원리는 간단한데, 아래처럼 두 테이블의 가능한 조합을 모두 확인한다고 보면 된다. 그래서 성능적인 문제가 있기 때문에 꼭 필요할 때만 사용되는 방식이다.\n\n아래는 NestedLoopJoin 을 사용했을 때의 실행 계획이다.\n\n위의 실행 계획은 큰 테이블(right.csv)을 두 개의 파티션으로 나눈 다음 작은 테이블(left.csv)과 가능한 조합을 모두 확인한다. 앞의 HashJoin 은 작은 테이블이 충분히 작지 않다면 여러 개의 파티션으로 나누어서 처리하는 것이 가능하지만, NestedLoopJoin 에서는 작은 테이블을 나누면 모든 조합을 확인할 수 없기 때문에 큰 테이블만 나누어서 처리하는 것이 가능하다.\n지금까지 Datafusion 에서 조인이 어떻게 동작하는지 살펴보았다. 이외에도 다양한 최적화 기술들을 이미 지원하고 있고, 앞으로 지원될 예정인 기술들도 많으니 기회될 때마다 소개드리도록 하겠다.\n","description":"","id":"https://haruband.github.io/datafusion-join/","title":"[Arrow/Datafusion] 동작 과정 분석 (Join)"},"https://haruband.github.io/datafusion-overview/":{"body":"Datafusion 은 최근 빅데이터 분야에서 널리 사용되고 있는 Arrow 를 이용하여 Rust 기반으로 개발 중인 임베딩 SQL 엔진이다. 이미 다양한 분야에서 활용되고 있는 DuckDB 와 유사한 목적을 가지고 있지만, Rust 로 개발 중이기 때문에 메모리 관리가 편리하고 확장성이 굉장히 뛰어나다는 장점이 있다. 이러한 장점들로 인해 최근 Datafusion 을 이용하여 기존 솔루션보다 탁월한 성능을 보여주는 새로운 오픈소스들이 많이 등장하고 있고, 특히 Java/Scala 중심의 빅데이터 분야에서 많은 변화를 주도할 것으로 기대된다. 그럼 이제 Datafusion 에 대해 자세히 살펴보도록 하자.\n우선, 오랜 시간 널리 사용되고 있는 Spark 와 비교했을 때 어떤 부분이 차이가 있는지 살펴보도록 하자. (Spark 와 비교하는 이유는, Datafusion 을 Pandas 와 비교할 수도 있겠지만 개인적으로 Spark 의 대체제로 활용하고 있기 때문이다.)\n설치/운영\nSpark 는 대규모 클러스터 환경에서 빅데이터를 처리하기 위해 개발되었기 때문에 설치와 운영에 높은 전문 지식과 노력이 필요하다. 하지만 Datafusion 은 어디에나 임베딩할 수 있기 때문에 비교적 간단하게 사용할 수 있고, 수백대에서 수천대의 대규모 클러스터에서 처리하는 데이터를 처리하긴 힘들지만 수십대의 클러스터에서 처리하는 데이터는 처리할 수 있다. 그리고 서버에 설치할 수 있는 CPU 와 메모리가 늘어날수록 처리할 수 있는 데이터는 지속적으로 늘어날 것이다. (참고로, Datafusion 을 분산 클러스터 환경에서 사용하려는 시도도 있긴 하다.)\n데이터 구조\nSpark 는 기본적으로 Row 기반으로 동작하기 때문에 Column 단위로 분석하는 요청에서는 효율이 떨어진다. 이러한 문제를 해결하기 위해 C++ 를 이용한 Column 기반의 새로운 엔진과 Arrow 기반의 Velox 를 실행 엔진으로 사용하려는 시도가 있지만, 아직 여러 가지 제약 사항이 많다. 하지만 Arrow 기반의 Datafusion 은 Column 단위로 동작하기 때문에 대부분의 분석 쿼리에서 효율적으로 동작한다. 여기에는 연속된 메모리에 대한 반복 처리를 자동으로 Vectorization 해주는 LLVM 의 AutoVectorization 이 큰 역할을 하고 있다.\n메모리 관리\nJava 에서 메모리 관리를 도와주는 GC (Garbage Collection) 는 다양한 문제를 유발한다. GC 가 동작할 때마다 시스템 자원을 낭비하고 예측할 수 없는 지연시간을 발생시키기도 하며, 예상하기 힘든 OOM (Out-Of-Memory) 의 원인이 되기도 한다. 그리고 더 많은 메모리가 필요해서 JVM 이 사용하는 힙(Heap)의 크기를 늘리면 GC 에 의해 관리되는 영역도 늘어나기 때문에 앞서 언급한 문제들이 더욱 심각해질 수 있다. 하지만 Rust 는 GC 없이 메모리 안정성을 보장하기 때문에 필요한 만큼 시스템 메모리를 사용할 수 있고, 스왑 메모리도 효과적으로 사용할 수 있다. Java 는 GC 에 의해 메모리를 적절히 정리하지 않으면 예기치 못한 OOM 이 발생하지만, Rust 는 커널이 직접 제공하는 스왑 기능 덕분에 충분한 시스템 메모리와 스왑 메모리만 있다면 OOM 은 발생하지 않는다.\n실행 방식\nJava 는 바이트 코드로 컴파일되어 배포되기 때문에 성능을 높이기 위해 JIT (Just-In-Time) 방식을 사용하고 있다. 이는 자주 실행되는 바이트 코드를 런타임에 컴파일하여 네이티브 코드(x86, arm, ...)로 변환하는 기술인데, 이를 위한 준비 과정이 필요하며 LLVM 과 같은 컴파일러에 비해 충분한 최적화가 이루어지지 않는 문제가 있다. 하지만 Rust 는 네이티브 코드로 컴파일되어 배포되기 때문에 LLVM 이 제공하는 높은 수준의 최적화를 충분히 활용할 수 있다.\n아래 그림은 Datafusion 이 동작하는 방식을 간단히 보여주고 있다. (대부분의 SQL 엔진이 비슷한 방식으로 동작한다.)\n\n동작 과정을 정리해보면 아래와 같다.\n\nSQL 쿼리 혹은 DataFrame 을 논리 계획으로 변환\n논리 계획 최적화 (ConstantFolding, CommonSubexpressionElimination, ...)\n논리 계획을 실행 계획으로 변환\n실행 계획 최적화 (Sort, Aggregation, Join, ...)\n실행 계획에서 스트림 추출\n스트림에서 데이터 수집\n\n일반적인 컴파일러가 동작하는 방식과 유사한 부분이 많은데, 논리 계획(LogicalPlan)은 상위 수준 중간 언어(IR)라고 보면 되고 실행 계획(ExecutionPlan)은 하위 수준 중간 언어라고 보면 된다. 논리 계획과 실행 계획은 실제 데이터를 수집 및 처리하는 역할을 하는 스트림(Stream)을 생성하고, 하나의 스트림은 하나의 파티션(데이터)을 하나의 스레드에서 처리한다고 생각하면 간단하다. 데이터는 현재 표준처럼 널리 사용되고 있는 Arrow 의 RecordBatch 형식을 사용한다.\n간단한 예제를 보면서, SQL 쿼리가 논리 계획과 실행 계획으로 어떻게 변환되는지, 최적화에 의해 실행 계획과 스트림이 어떻게 변환되는지 살펴보도록 하자.\n데이터(Parquet) 파일을 읽어서 정렬한 후 두 개의 컬럼을 보여주는 간단한 SQL 쿼리를 실행해보자.\n\n위의 쿼리는 아래와 같은 논리 계획으로 변환된다.\n\n위의 논리 계획은 테이블에서 두 개의 컬럼[company, score]을 읽어서 전달하는 부분(TableScan)과 전달받은 데이터를 정렬하는 부분(Sort)으로 구성되어 있다. (실제 데이터는 아래에서 위로 전달된다.) 위의 논리 계획은 아래와 같은 실행 계획으로 변환된다.\n\n테이블을 읽는 논리 계획(TableScan)은 데이터(Parquet) 파일의 형식에 따라 ParquetExec 실행 계획으로 변환되었고, 정렬하는 논리 계획(Sort)은 여러 가지 상황에 따라 SortExec 실행 계획으로 변환되었다. 논리 계획도 마찬가지이지만, 최적화 옵션이나 여러 가지 상황에 따라서 실행 계획은 달라진다. 위의 실행 계획이 실행되면, SortExec 가 아래 그림의 SortStream 을, ParquetExec 가 FileStream 을 생성한다.\n\n체인 형태로 연결된 스트림은 유효한 데이터가 더 이상 없을때까지 반복적으로 실행되면서 데이터를 뒤에서 앞으로 전달하는 방식으로 동작한다. FileStream 은 두 개의 데이터 파일을 읽어서 SortStream 으로 전달하고, SortStream 은 모든 데이터를 수집한 다음 정렬한 결과를 전달한다.\n위의 예제를 자세히 살펴보면, 두 개의 파일을 하나의 스트림에서 읽는 것을 볼 수 있다. 이를 조금 더 개선할 수 있는 방법은 없을까? 두 개의 파일을 두 개의 스트림에서 각각 읽는다면 성능이 개선될 수 있지 않을까? Datafusion 에서는 파티션 개수를 조절하여 이를 개선할 수 있다. 아래는 두 개의 파티션을 사용하도록 설정했을 때의 실행 계획을 보여준다.\n\n두 개의 파티션을 사용하도록 설정했더니 ParquetExec 에서 두 개의 파일 그룹이 생성된 것을 볼 수 있다. 이 실행 계획은 아래 그림처럼 각각의 파일 그룹을 처리하는 두 개의 FileStream 을 생성한다.\n\n이제 두 개의 FileStream 은 각각 하나의 데이터 파일을 읽고, CoalesceStream 에서 두 개의 FileStream 을 하나로 합쳐서 SortStream 에 전달한다.\n위의 실행 계획은 어떤 문제를 가지고 있을까? 여러 데이터 파일을 병렬로 읽는 부분은 좋지만, 이를 하나로 합쳐서 정렬하는 부분은 개선의 여지가 있어보인다. Datafusion 에서는 파티션별로 먼저 정렬하는 병합 정렬(MergeSort)을 지원하기 때문에 이를 활용하여 실행 계획을 조금 더 개선해보자.\n\n위의 실행 계획은 아래와 같은 스트림을 생성한다.\n\n두 개의 FileStream 이 각각 하나의 데이터 파일을 읽고 SortStream 에서 각각 정렬한 다음, SortPreservingMergeStream 이 합쳐서 최종적으로 정렬한다.\n지금까지 Datafusion 이 어떻게 동작하는지를 하나의 예제를 통해 살펴보았다. 이외에도 다양한 쿼리와 최적화를 지원하고 있고, 이미 충분히 좋은 성능을 보여주고 있지만 굉장히 활발하게 새로운 기능이 추가되고 개선되고 있다. Datafusion 을 기반으로 새롭게 등장한 여러 솔루션처럼 Datafusion 은 여러 가지 문제에 대한 새로운 가능성으로 충분히 자리매김할 것으로 기대된다.\n","description":"","id":"https://haruband.github.io/datafusion-overview/","title":"[Arrow/Datafusion] 동작 과정 분석"},"https://haruband.github.io/delta-checkpoints/":{"body":"스파크를 이용하여 스트리밍 데이터를 델타레이크로 저장할 때 체크포인트가 성능에 어떠한 영향을 미치는지 살펴보고, 이를 개선할 수 있는 멀티파트 체크포인트 기능에 대해 알아보도록 하자.\n(아래의 실험 환경은 모두 마이크로 배치 간격이 1 분으로 설정되어 있다.)\n\n위의 그래프는 실험 환경에서 스파크 스트리밍의 마이크로 배치 처리시간을 시간순으로 보여주고 있다. 마이크로 배치에서는 특별한 작업없이 바로 (델타) 테이블에 저장하기 때문에 대부분의 처리시간은 저장하는데 소요된다. 그리고 중간에 반복적으로 한번씩 튀는 것은 델타레이크에서 10 번의 쓰기 작업마다 새로운 체크포인트 파일을 만들기 때문이다. (배치 간격이 1 분이기 때문에 대략 10 분에 한번씩 그래프가 튀는 것을 볼 수 있다.) 그럼 이제 스트리밍 데이터를 처리한 후, 테이블에 저장하는 과정을 자세히 분석해보도록 하자.\n델타레이크에서는 테이블을 최신 상태로 유지하기 위해 쓰기 작업이 끝날 때마다 (델타로그) 스냅샷을 갱신한다. 이를 위해 마지막 체크포인트 파일과 이후의 로그 파일들을 이용하여 스냅샷에서 사용하는 (스파크) 데이터프레임을 만든다. 델타레이크는 체크포인트 파일을 위한 FileScanRDD 와 로그 파일들을 위한 FileScanRDD 를 각각 만들어서 파일들을 읽어들인 다음, 하나의 RDD 로 합친 후 설정된 값(기본값 50)으로 리파티셔닝(repartition)한다.\n(델타로그도 빅데이터이기 때문에 병렬 처리가 중요하다.)\n아래는 체크포인트 파일과 로그 파일들을 읽어서 리파티셔닝을 위한 셔플 쓰기(Shuffle Write)를 하는 스테이지를 보여주고 있다. 17 개의 태스크가 생성되었지만, 제대로 파일을 읽는 태스크는 6 번 (125MB), 13 번 (34MB), 그리고 16&nbsp;번 (753KB) 밖에 없다. 왜 이런 상황이 벌어졌는지 자세히 살펴보자.\n\n우선 왜 17 개의 태스크가 생성되었을까? 스파크에서는 FileScanRDD 가 사용할 파티션을 만들 때, 하나의 파티션에서 읽을 수 있는 파일의 최대 크기를 정하는데 이 때 몇 가지 변수들(maxPartitionBytes, openCostInBytes, ...)과 전체 코어 개수를 사용한다. 해당 실험 환경에서는 이렇게 계산된 최대 파일 크기가 대략 10MB 였고, 그래서 160MB 정도 크기인 체크포인트 파일을 분할하여 읽기 위한 16 개의 파티션과 1 개의 로그 파일을 읽기 위한 1 개의 파티션이 만들어져서 총 17 개의 태스크가 생성되었다.\n(마지막 체크포인트 이후 하나의 로그만 생성되었기 때문에 1 개의 로그 파일만 추가로 읽으면 되었다.)\n그런데 왜 하나의 로그 파일을 읽는 태스크를 제외하고, 두 개의 태스크만 체크포인트 파일을 읽었을까? 이유는 파케이(Parquet) 포맷을 사용하는 체크포인트 파일의 블럭 크기가 128MB 이기 때문에 2 개의 블럭(125MB, 34MB)만을 가지고 있었고, 그래서 각 블럭의 중간 위치를 포함하는 태스크인 6 번과 13 번 태스크만이 해당 블럭을 읽었기 때문이다.\n이러한 이유로 해당 스테이지에서는 17 개의 태스크를 사용했지만 하나의 태스크가 125MB 를 읽으면서 5 초의 시간이 소요되었다.\n아래는 50 개의 태스크에서 셔플 읽기(Shuffle Read)를 하는 스테이지를 보여주고 있고, 이후 델타로그와 관련된 연산은 해당 RDD 에서 50 개의 파티션으로 나누어져서 처리된다.\n\n이러한 과정을 통해 일반적인 쓰기 작업은 위의 그래프에서 보면 대략 20 초 정도 걸리는 것을 알 수 있다. 그리고 지금부터는 10 번의 쓰기 작업마다 처리시간이 40 초 이상 걸리는 이유인, 주기적으로 새로운 체크포인트 파일을 만드는 부분에 대해 자세히 살펴보도록 하자.\n새로운 체크포인트 파일을 만드는 부분에서 성능적으로 가장 문제가 되는 것은 체크포인트가 하나의 파일로 만들어진다는 점이다. 위에서 설명한 것처럼 하나의 파케이 파일을 읽는 작업은 여러 태스크에서 서로 다른 블럭을 동시에 읽어서 처리시간을 줄일 수 있지만, 하나의 파케이 파일에 쓰는 작업은 하나의 태스크에서만 처리할 수 있기 때문이다.\n아래는 50 개의 파티션으로 나뉘어 처리되던 RDD 를 하나의 파티션을 가지는 RDD 로 합치기 위해 셔플 쓰기를 하는 스테이지를 보여주고 있다.\n\n그리고 하나의 태스크에서 셔플 읽기를 하고, 하나의 체크포인트 파일을 만드는 스테이지는 아래와 같다. 아직 체크포인트 파일의 크기가 163MB 밖에 되지 않지만 20 초나 걸리는 것을 볼 수 있다. 이 처리시간은 로그가 쌓이면 쌓일수록 체크포인트 파일의 크기가 커져서 점점 더 길어질 수 밖에 없기 때문에 실시간으로 스트리밍 데이터를 저장하기 위해서는 무언가 해결책이 필요해 보인다.\n\n이를 해결하기 위해 나온 것이 바로 멀티파트 체크포인트 기능이다. 기능 자체는 단순하다. 기존에 하나의 파일로 관리되던 체크포인트를 여러 파일로 분할해서 관리하자는 것이다. 사용법도 매우 간단한데, 관련 옵션(spark.delta.checkpoint.partSize)을 이용해서 하나의 체크포인트 파일에 담을 수 있는 최대 로그 개수를 지정하면 된다.\n그럼 이제 멀티파트 체크포인트 기능을 사용했을 때 어느 정도의 성능이 개선되는지 살펴보자. 실험 환경에서는 최대 로그 개수를 10 만개로 지정하였고, 체크포인트 파일 1 개의 크기는 대략 20MB&nbsp;정도까지다. 체크포인트 파일을 읽는 부분과 쓰는 부분만 간단히 살펴보자.\n아래의 체크포인트 파일을 읽는 스테이지를 보면, 체크포인트 파일의 크기가 모두 합쳐서 160MB 정도이고 마지막 체크포인트 이후 4 개의 로그가 생성되었기 때문에 20 개의 태스크가 할당되었고, 160MB 정도의 체크포인트 파일이 8 개로 분할되어 있기 때문에 8 개의 태스크가 동시에 체크포인트 파일을 읽어들이는 것을 알 수 있다. 그래서 해당 스테이지는 대략 1 초 정도 밖에 걸리지 않는다.\n\n다음으로 체크포인트 파일을 쓰는 스테이지를 보면, 대략 70 만개 정도의 로그를 최대 10 만개씩 8 개의 파일로 분할해서 저장하기 위해 8 개의 태스크가 할당된 것을 볼 수 있다.\n\n마지막으로 멀티파트 체크포인트 기능을 사용하는 경우 마이크로 배치 처리시간이 얼마나 개선되는지도 간단히 살펴보자.\n\n초록색은 하나의 체크포인트 파일을 사용한 경우이고, 노란색은 멀티파트 체크포인트 파일을 사용한 경우이다. 보시는 바와 같이 일반적인 쓰기 작업 시에도 체크포인트 파일을 읽는 속도가 빨라져서 7~8 초 정도 성능이 개선되었고, 새로운 체크포인트 파일을 만드는 부분에서는 20 초 이상 성능이 개선된 것을 볼 수 있다.\n지금까지 멀티파트 체크포인트 기능을 사용하면 성능적으로 어떤 부분이 어느 정도 개선될 수 있는지 살펴보았다. 실시간 스트리밍처럼 잦은 쓰기 작업이 필요한 서비스에서는 적절한 로그 보관(retention) 정책과 함께 잘 활용하면 좋은 성능을 기대할 수 있을 것이다.\n","description":"","id":"https://haruband.github.io/delta-checkpoints/","title":"[Delta] 델타로그 체크포인트 분석"},"https://haruband.github.io/delta-cleanup/":{"body":"최근 스파크를 이용하여 스트리밍 데이터를 델타레이크로 저장할 때 발생한 문제를 소개하고자 한다. 현재 작업 중인 환경에서는 스파크 스트리밍의 마이크로 배치 처리시간이 평균적으로 일반적인 쓰기 작업은 10 초 내외이고, 10 번의 쓰기 작업마다 새로운 체크포인트 파일을 만들 때는 2~30 초 정도이다. 그런데 주기적으로 새로운 체크포인트 파일을 만들 때 400 초 정도의 시간이 소요되는 문제를 발견하였다. 오늘은 왜 이런 문제가 발생하였는지 살펴보도록 하자.\n\n위의 그래프는 문제 발생 시 배치 처리시간을 보여주고 있다. 보시는 바와 같이 오전 9 시 15 분쯤 배치 처리시간이 400 초를 넘어서는 것을 볼 수 있다. 그리고 지난 며칠 간의 데이터를 분석해보니, 매일 같은 시간에 같은 문제가 반복되고 있는 것을 알 수 있었다.\n\n위의 그래프는 해당 문제가 발생했을 때 스파크 스트리밍에 사용된 익스큐터(Executor)의 태스크 처리 시간을 보여주고 있다. 현재는 2 개의 익스큐터를 사용 중인데, 해당 시간에만 2 개의 익스큐터 모두 아무런 작업을 하지 않은 것을 볼 수 있다. 이를 통해 스파크 스트리밍에 사용된 드라이버에서 반복적으로 해당 시간에 문제가 발생하고 있다고 예상할 수 있다.\n(어떤 문제가 규칙성을 보이면, 가비지 컬렉션(Gabage Collection) 혹은 어떠한 자원 경쟁에 의한 문제는 아니라고 볼 수 있다.)\n그래서 문제가 발생했을 때의 상황을 이해하기 위해 드라이버의 콘솔 로그를 분석하였고, 결과적으로 아래와 같이 문제의 원인을 파악할 수 있었다. 아래 로그를 보면, 드라이버가 어떠한 작업을 처리하기 위해 400 초 정도의 시간을 보낸 것을 알 수 있다. 이로 인해 다음 마이크로 배치 처리가 지연되면서 모든 익스큐터가 대기 상태가 된 것이다.\n\n그럼 이제 정확히 어떤 작업으로 인해 이러한 문제가 발생했는지 좀 더 알아보도록 하자.\n위의 작업은 델타레이크에서 보관 기간(logRetentionDuration)이 지난 로그 파일을 지우는 것이다. 해당 작업은 매일 UTC 기준으로 0 시에 실행되고, 그래서 한국시간(UTC+9)으로 오전 9 시쯤 실행되었다. 정확히는 UTC 기준으로 0 시가 지나고 처음 체크포인트 파일을 만들 때 해당 작업이 실행된다. 현재 작업 환경에서는 마이크로 배치 간격이 1 분이기 때문에 하루에 생성되는 로그의 개수는 1440 개 정도이고, 체크포인트 파일도 같은 방식으로 지워지기 때문에 해당 작업에서 지워지는 파일의 수는 대략 2 천개 정도이다. 즉, 드라이버에서 오브젝트 스토리지에 저장되어 있는 2 천개의 파일을 지우기 위해 대략 400 초 정도의 시간을 소요한 것이다.\n지금까지 주기적으로 보관 기간이 지난 로그 파일을 지울 때 발생하는 문제를 살펴보았다. 쓰기 작업이 많은 서비스일수록 지워야하는 로그 파일이 많아져서 지연 시간이 길어질 수 있으니 여러 가지 개선할 수 있는 방법에 대한 고민이 필요하다.\n","description":"","id":"https://haruband.github.io/delta-cleanup/","title":"[Delta] 델타로그 CleanUp 문제 분석"},"https://haruband.github.io/delta-filtering/":{"body":"델타레이크는 효율적인 읽기 작업을 위해 여러 가지 최적화 기법을 제공한다. 최적화 기법은 크게 델타로그를 이용해서 데이터 파일을 필터링하는 방식과 파케이(Parquet)가 제공하는 필터링 기능을 이용하는 방식으로 나뉜다. 오늘은 아래 예제를 이용해서 필수적인 최적화 기법들이 어떻게 적용되는지 하나씩 살펴보자.\n(델타레이크의 모든 데이터 파일은 파케이(Parquet) 형식이다.)\n\nPartition Pruning\n델타레이크는 사용 중인 파티션 필드에 대한 정보를 메타데이터(metadata) 로그에 담고 있다. 아래 로그를 보면 두 개의 파티션 필드(year, gender)를 사용하고 있는 것을 알 수 있다.\n\n각각의 데이터 파일에 대한 파티션 정보는 아래와 같이 파일추가(add) 로그에 저장되어 있다. partitionValues 필드에 각각의 파티션 정보를 가지고 있는데, 아래 로그에서 첫 번째 데이터 파일의 year 필드는 \"2000\" 이고 gender 필드는 \"male\" 인 것을 볼 수 있다. 그래서 데이터 파일의 경로(path)는 \"year=2000/gender=male/..\" 로 시작한다.\n\n델타레이크는 내부적으로 필요한 로그 정보를 스파크의 데이터프레임으로 관리하고 있고, 위의 파일추가(add) 로그만을 모은 데이터프레임에서 partitionValues 필드를 필터링하는 방식으로 동작하기 때문에 파일의 수가 많아도 빠르게 병렬 처리가 가능하다.\n아래는 예제의 물리적 실행 계획에서 파티션 프루닝이 적용된 모습이다. 예제의 조건문(where) 중에서 파티션 필드에 해당하는 year, gender 필드만 추가되어있다.\n\nPredicate Pushdown\n델타레이크에서 조건절 푸시다운(Predicate Pushdown)은 크게 두 단계로 동작한다. 첫 번째 단계는 델타로그의 파일추가 로그에 있는 통계 정보를 이용하여 데이터 파일을 필터링하는 것이고, 두 번째 단계는 파케이가 제공하는 푸시다운 기능을 이용하여 행 그룹을 필터링하는 것이다.\n우선 델타로그부터 살펴보자. 아래 파일추가 로그에서 통계 정보인 stats 필드를 보면 각 필드의 최대값(maxValues)과 최소값(minValues)을 알 수 있기 때문에, 파티션 프루닝과 마찬가지로 파일추가 로그만을 모은 데이터프레임에서 stats 필드를 필터링하는 방식으로 빠르게 조건에 맞는 파일들을 찾을 수 있다.\n\n아래는 예제의 물리적 실행 계획에서 조건절 푸시다운이 적용된 모습이다. 예제의 조건문 중에서 파티션 필드를 제외한 salary 필드만 추가되어있다.\n\n그리고 스파크가 이미 파케이 파일에 대한 푸시다운 기능을 제공하고 있기 때문에 이를 활용하면, 데이터 파일 전체가 아닌 필요한 행 그룹만을 빠르게 가져올 수 있다. 아래는 예제의 물리적 실행 계획에서 조건절 푸시다운이 적용된 모습이다. 파티션 필드는 파케이 파일에 포함되어 있지 않기 때문에 파티션 필드를 제외한 salary 필드만 추가되어있다.\n\nProjection Pruning\n파케이 파일에서 특정 필드만 읽는 기능도 스파크가 이미 제공하고 있기 때문에 이를 활용하면 불필요한 필드를 가져오는 비용을 줄일 수 있다. 아래는 예제의 물리적 실행 계획에서 프로젝션 프루닝이 적용된 모습이다. 예제의 선택문(select) 중에서 파티션 필드는 파케이 파일에 포함되어 있지 않기 때문에 파티션 필드를 제외한 salary 필드만 추가되어있다.\n\n지금까지 소개한 최적화 기법을 이용하면 델타레이크를 통해 필요한 데이터 파일에서, 필요한 행 그룹에서, 필요한 필드만을 효과적으로 가져와서 처리할 수 있다.\n","description":"","id":"https://haruband.github.io/delta-filtering/","title":"[Delta] 읽기 성능 최적화"},"https://haruband.github.io/delta-optimize/":{"body":"델타레이크는 쓰기 작업이나 여러 최적화 과정(Compaction, Z-Order, ...)이 반복될수록 로그가 쌓여간다. 이렇게 로그가 지속적으로 쌓여가면 마지막 상태 정보를 담고 있는 스냅샷을 만드는 작업이 점점 더 오래 걸릴 수 밖에 없어진다. 이 문제를 개선하기 위해 델타레이크는 몇 가지 기능을 제공하고 있다. 오늘은 이에 대해 간단히 살펴보고자 한다.\n지나간 로그 파일 정리\n로그 파일이 많아져도 스냅샷을 만들 때는 마지막 체크포인트 파일과 이후의 로그 파일만 사용되지만, 로그 파일이 많아지는 것 자체가 스토리지에 부담을 준다. 그래서 델타레이크는 일정 기간이 지난 로그 파일을 제거하는 기능을 제공하고 있다. 사용법은 아래와 같다.\n(현재 S3 스토리지의 경우, 특정 버전 이후의 로그 파일을 가져오는 listFrom() 함수가 모든 로그 파일을 가져온 다음 필터링하는 방식으로 동작하고 있기 때문에 특히 문제가 심각하다. 하지만, 현재 이를 해결하기 위한 PR이 대기 중이다.)\n\n해당 옵션의 기본값은 30 일이고, 위와 같이 7 일로 지정하면 체크포인트 파일을 만들 때마다 7 일이 지난 로그 파일들은 제거한다. 여기서 주의할 점은 마지막 체크포인트 이후의 로그 파일은 제거되지 않는다. 이유는 아직 해당 로그 파일의 내용이 어떤 체크포인트 파일에도 포함되지 않았기 때문이다. 그리고 또 한 가지 주의할 점은 해당 기간 이전으로는 롤백할 수 없게 된다. 이유는 롤백할 때 마지막 체크포인트부터 지정한 버전까지의 로그 파일들이 필요하기 때문이다.\n지워진 파일 로그 정리\n로그가 쌓이면 체크포인트 파일의 크기도 꾸준히 증가하기 때문에 스냅샷을 만들 때 문제가 될 수 있다. 이를 개선하기 위해서는 불필요한 로그를 꾸준히 없애주는 작업이 필요하다. 델타레이크는 데이터에 대한 변경이나 최적화를 할 때 기존 데이터 파일은 그대로 두고 새로운 데이터 파일을 추가하기 때문에 기존 데이터 파일은 롤백할 때를 제외하곤 필요없어진다. 그래서 아래와 같이 옵션을 지정하면 체크포인트 파일을 만들 때마다 해당 기간이 지난 불필요한 로그들은 제거된다. 여기서 말하는 불필요한 로그들은 데이터 파일을 삭제(remove)하는 로그와 해당 데이터 파일을 추가(add)했던 로그이다.\n\n참고로, 델타레이크가 제공하는 Vacuum 명령어는 지정한 기간이 지난 불필요한 데이터 파일을 지우는 역할을 한다. 위의 기능과는 별개로 동작한다.\n체크포인트 파일 쪼개기\n델타레이크는 내부적으로 스파크를 사용하고 있기 때문에 스냅샷은 스파크의 데이터프레임으로 만들어진다. 그래서 체크포인트 파일을 여러 개의 파일로 쪼개서 병렬로 읽고/쓰는 것이 가능하다. 특히, 이 기능은 스파크 스트리밍을 통해 실시간으로 데이터를 델타레이크에 저장할 때 유용하다. 해당 기능이 없다면, 스파크 스트리밍에서 10 번에 한 번씩 하나의 익스큐터에서 체크포인트 파일을 만드는 것을 기다려야 하기 때문에 반복적인 지연이 발생할 수 밖에 없다. 하지만 해당 기능을 사용하면 10 번에 한 번씩 체크포인트 파일을 만드는 작업을 여러 익스큐터에서 병렬로 처리할 수 있기 때문에 지연 시간을 줄일 수 있다.\n지금까지 델타레이크에서 지속적으로 쌓여가는 로그를 어떻게 효율적으로 관리하는지 살펴보았다.\n","description":"","id":"https://haruband.github.io/delta-optimize/","title":"[Delta] 델타로그 최적화"},"https://haruband.github.io/delta-overview/":{"body":"스파크로 유명한 데이터브릭스에서 몇 년전에 공개한 델타레이크(DeltaLake)라는 기술은 데이터레이크와 데이터웨어하우스의 장점을 합친 레이크하우스 아키텍처의 핵심 기술이다. 이는 기존에 (기술적인/비용적인 한계로 인해) 원시 데이터는 데이터레이크에, 가공 데이터는 데이터웨어하우스에 저장하던 방식을 원시/가공 데이터 모두를 하나의 레이크하우스에 저장하는 방식으로 개선하여 효율적으로 빅데이터 플랫폼을 구축 및 관리할 수 있게 만들고 있다. 오늘은 데이터브릭스에서 레이크하우스의 핵심 기술로 개발하고 있는 델타레이크의 가장 중요한 부분인 델타로그(DeltaLog)에 대해 간단히 살펴보도록 하자.\n레이크하우스를 한 마디로 표현하면 ACID(Atomic, Consistent, Isolated, Durable)를 지원하는 데이터레이크라고 볼 수 있다. 즉, 데이터레이크에서 주로 사용하는 저렴한 스토리지를 이용하여 데이터웨어하우스만의 장점인 ACID 를 지원하는 것이 핵심이다. 그럼 어떻게 일반적인 스토리지 위에서 안정적인 트랜잭션을 지원할 수 있는 것일까? 그 해답이 바로 델타로그이다.\n델타레이크는 한 번의 쓰기 작업에서 반드시 하나의 로그 파일을 생성한다. 파티셔닝이나 파일당 크기 제한 등으로 인해 여러 개의 데이터 파일이 생성되더라도 해당 쓰기 작업의 모든 행위(Action)는 하나의 로그 파일에 함께 기록된다. 간단한 예제를 통해 조금 더 자세히 살펴보자.\n(두 개 이상의 쓰기 작업에서 문제없이 동시에 로그 파일을 생성하기 위해서는 스토리지에서 PutIfAbsent 기능을 반드시 제공해야 한다.)\n아래는 스파크로 개발한 간단한 예제 프로그램을 실행한 결과이다. 보이는 것처럼 한 번의 쓰기 작업에 총 6 개의 데이터 파일과 1 개의 로그 파일이 생성되었다. 스파크는 익스큐터(Executor)에서 각각 데이터 파일을 생성 후 파일의 경로를 드라이버(Driver)에게 전송한다. 그리고 드라이버는 익스큐터로부터 모든 데이터 파일의 경로를 수집한 다음, 하나의 로그 파일을 생성한다. (델타레이크는 모든 로그 파일을 _delta_log 폴더 아래에 생성한다.)\n\n아래는 위의 로그 파일의 내용이다. 다른 내용은 생략하고, 총 6 개의 데이터 파일이 추가(add)되었다는 내용만 남겨두었다.\n\n그리고 기존 데이터를 삭제하거나 변경하면 어떻게 될까? 이것 또한 간단하다. 아래는 기존 데이터를 변경했을 때 추가로 생성된 로그 파일의 내용이다.\n\n마찬가지로 다른 내용은 생략하고, 기존 데이터 파일은 삭제(remove)되고 변경된 데이터 파일이 추가(add)되었다는 내용만 남겨두었다.\n이처럼 쓰기 작업은 간단하지만, 모든 로그 기반 시스템이 그렇듯이, 읽기 작업은 간단하지 않다. 기본적으로 모든 로그 히스토리를 순차적으로 분석해서 마지막 상태 정보를 담고 있는 스냅샷(Snapshot)을 만드는 작업이 필요한데, 쓰기 작업이 반복될수록 로그 파일이 많아져서 스냅샷을 만드는 작업이 점점 더 오래 걸릴 수 밖에 없어진다. 이 문제를 개선하기 위해 델타레이크는 체크포인트(Checkpoint)라는 기능을 제공한다. 이는 간단히 말하면 해당 시점까지의 모든 로그를 가지고 있는 하나의 파일(Parquet)을 만드는 것이다.\n아래는 25 번의 쓰기 작업이 실행된 결과이다. 0~24 까지 총 25 개의 로그 파일이 생성되었지만, 10 번마다 체크포인트 파일이 추가된걸 볼 수 있다. 델타레이크는 10 의 배수에 해당하는 로그 파일을 쓸 때 과거 모든 기록을 담고 있는 체크포인트 파일도 같이 추가한다. 그래서 총 2 개의 체크포인트 파일이 보이고, _last_checkpoint 파일은 마지막에 생성한 체크포인트의 번호를 가지고 있다.\n\n정리하면, 델타레이크에서 읽기 작업시 스냅샷을 만드는 과정은 아래와 같다.\n\n_last_checkpoint 파일에서 마지막 체크포인트 번호를 가져온다.\n마지막 체크포인트 파일을 읽는다.\n마지막 체크포인트 파일 이후에 생성된 로그 파일들을 읽는다.\n\n그래서 로그 파일이 아무리 많이 쌓이더라도 스냅샷을 만들 때 필요한 파일은 최대 11 개뿐이다. (_last_checkpoint, checkpoint file, x1~x9.json files)\n지금까지 델타레이크에서 델타로그가 어떻게 사용되고 있는지 살펴보았다.\n","description":"","id":"https://haruband.github.io/delta-overview/","title":"[Delta] 델타로그 분석"},"https://haruband.github.io/ebpf-core/":{"body":"최근 몇 년간 리눅스 커널 커뮤니티에서 가장 주목받고 있는 기술은 누가 뭐래도 eBPF 일 것이다. 리눅스 커널에 안정성과 확장성, 그리고 생산성을 동시에 부여하는 혁신적인 기술로, 대표적인 쿠버네티스의 CNI 인 Cilium과 Falco, Pixie 등 다양한 오픈소스 프로젝트의 기반 기술로 이미 자리잡고 있으며, 점점 더 활용분야를 넓혀나가고 있다. 오늘은 최근 eBPF 커뮤니티에서 주요 기능 중의 하나로 인식되고 있는 CO-RE(Compile Once - Run Everywhere)에 대해 간단히 소개하고자 한다. 우선 해당 기술이 왜 필요한지부터 살펴보도록 하자.\n아래 코드는 bcc 의 runqslower 예제코드 중 일부이다. 아래 함수는 리눅스 커널에서 문맥전환(context-switching)이 일어날때 실행되는 trace_sched_switch() 함수에서 호출되는 BPF 함수이다. (섹션 이름인 tp_btf/sched_switch 가 sched_switch 트레이스포인트에 해당 함수를 추가하라는 의미이다.)\n\n위의 코드를 보면, 리눅스의 프로세스 자료구조(task_struct 구조체)에서 현재 상태(state)를 확인하는 부분이 있다. 이 C 코드를 BPF 코드로 컴파일하면 아래와 같다.\n\n위의 BPF 코드를 간단히 해석해보면 (2:) r7 레지스터에 prev 구조체의 포인터를 저장한 다음 (10:) r1 레지스터에 prev 의 state 필드의 값을 저장하고, (11:) r1 레지스터의 값이 TASK_RUNNING(0) 인지를 확인해서 분기한다. 여기서 (10:)을 살펴보면 prev 구조체 포인터에서 state 필드를 접근할 때 16 이라는 오프셋을 사용하는데, 이는 무슨 의미일까? 이 코드를 컴파일할 때 사용한 커널 헤더 파일을 살펴보자.\n\n위의 헤더 파일을 살펴보면, task_struct 구조체에서 state 필드의 오프셋은 thread_info 필드 다음에 있기 때문에 thread_info 필드의 사이즈(12 바이트)를 16 바이트로 정렬해서 16 바이트가 된다. 즉, task_struct 구조체 포인터로부터 16 바이트 떨어진 위치의 8 바이트 메모리가 state 필드의 값인 것이다.\n여기서 문제가 하나 발생하는데 그것은 task_struct 구조체가 어떤 버전의 커널을 쓰는지, 어떤 설정으로 쓰는지에 따라서 조금씩 달라진다는 것이다. 아래는 필자가 사용 중인 개발서버 중 한 대의 커널 헤더 파일이다.\n\n앞에서 BPF 파일을 컴파일할 때 사용했던 커널 헤더와 달리 thread_info 구조체에 syscall_work 라는 필드가 추가되어있다. 이 개발서버에서 앞에서 컴파일한 BPF 파일을 그대로 사용하다면 state 필드의 오프셋이 잘못되어있기 때문에 심각한 오류가 발생할 것이다. 기존에는 이러한 문제를 해결하기 위해 BPF 파일을 사용하는 서버에서 매번 직접 BPF 파일을 컴파일해서 사용을 했다. 하지만 BPF 파일을 컴파일하기 위해서는 clang/llvm 라이브러리를 항상 같이 배포해야하고, 컴파일하는데도 많은 자원과 시간이 소모된다. 이러한 문제를 해결하기 위해 나온 것이 CO-RE(Compile Once - Run Everywhere), 즉 한번 컴파일된 BPF 파일이 어디서든 실행되게 만드는 기술이다.\nCO-RE 는 간단히 설명하면, BPF 파일의 실행을 준비하는 동안 현재 사용 중인 커널에서 동작할 수 있도록 몇 가지 작업을 하는 것이며, 그 중 하나가 특정 구조체의 필드에 접근하는 모든 명령어를 현재 사용 중인 커널 설정에 맞게 변경하는 것이다. 위의 예제를 이용하여 구체적인 동작 과정을 살펴보자. 우선 BPF 파일에는 컴파일시 사용된 다양한 메타정보를 포함하고 있는 BTF(BPF Type Format)가 있다. (BTF 는 리눅스 커널에서 범용적이고 복잡한 DWARF 대신에 효율적으로 BPF 를 지원하기 위해 만든 것이다.) 아래는 runqslower BPF 파일의 BTF 를 출력한 것이다.\n\n위에는 해당 BPF 파일을 컴파일할 때 사용한 구조체에 대한 구체적인 정보가 담겨있다. 앞에서 살펴본 것처럼 task_struct 구조체의 state 필드의 오프셋이 16 바이트(128 비트)인 것을 확인할 수 있다. 그리고 BTF 는 어떤 명령어에서 특정 구조체의 필드를 접근했는지에 대한 정보도 가지고 있는데, 이는 대략 아래와 같이 구성되어 있다. (일반적으로 이러한 정보를 재배치(relocation) 정보라고 한다.)\nInstOffTypeNameAccessStr\n10task_struct0:1\n\n이를 해석해보면 (10:) 명령어에서 task_struct 구조체의 0:1 필드를 참고한다는 의미이다. 여기서 0:1 은 복잡한 구조체에서 특정 필드를 찾아가는 일종의 경로라고 보면 된다. 처음 0 은 자기 자신을 의미하고 다음 1 은 두 번째 필드를 의미하기 때문에 0:1 은 task_struct 구조체의 state 필드를 의미한다. 즉, (10:) 명령어에서 task_struct 구조체의 state 필드를 참고한다는 의미이다. (일반적으로 구조체 안에 간단한 자료형뿐 아니라 구조체나 배열이 들어가는 경우가 많기 때문에 이러한 표현법을 사용한다.)\n위와 같은 BTF 정보를 이용하여 libbpf는 BPF 코드를 실행하기 전에 재배치 작업을 수행한다. 재배치는 위의 테이블에 나열된 구조체와 필드가 현재 사용 중인 커널에서는 어떻게 구성되어 있는지 확인하면서 이루어진다. 아래는 현재 사용 중인 커널의 BTF 를 출력한 결과이다.\n\n재배치 작업은 (10:) 명령어에서 참고하는 task_struct 구조체의 state 필드의 오프셋을 현재 사용 중인 커널의 BTF 를 참고하여 24 바이트(192 비트)로 변경하는 것이다. 그럼 마지막으로 이러한 재배치 작업을 거친 실제 커널에서 실행 중인 BPF 코드를 확인해보자.\n\n위는 커널에 로딩된 BPF 코드를 덤프한 것이고 (10:) 명령어를 보면 오프셋이 24로 변경되어 있는 것을 확인할 수 있다. 이와 같은 과정을 통해 우리는 BPF 파일을 다양한 서버에서 재컴파일없이 실행할 수 있게 되었다.\n","description":"","id":"https://haruband.github.io/ebpf-core/","title":"[eBPF] CO-RE (Compile Once - Run Everywhere) 기능 분석"},"https://haruband.github.io/ebpf-loading-jit/":{"body":"BPF 파일을 컴파일하면 BPF 코드가 생성된다. 이 BPF 코드는 자바 바이트코드처럼 특정 CPU 에 종속적이지 않은 일종의 중간코드이고, 리눅스 커널은 런타임에 몇 가지 방법으로 이 BPF 코드를 실행한다. 오늘은 리눅스 커널이 BPF 코드를 실행하는 방식에 대해 소개하고자 한다.\nbcc 의 filetop 예제코드를 이용하여 BPF 파일이 BPF 코드로 컴파일된 후 커널에서 실행되는 과정을 살펴보도록 하자. 아래는 예제코드의 일부분이다.\n\n위의 코드를 clang/llvm 을 이용하여 컴파일하면 아래와 같은 ELF 실행파일 구조로 만들어진 BPF 코드가 생성된다.\n\n이처럼 해당 예제코드를 컴파일하면 커널에서 바로 실행할 수 있는 두 개의 프로그램(BPF 코드)이 각각의 섹션에 존재하는 것을 볼 수 있다. 그리고 해당 프로그램 중 하나를 재배치 등 몇 가지 필요한 과정을 거쳐 커널에 로딩한 다음, 덤프해보면 아래와 같은 결과물을 볼 수 있다.\n\n위의 결과물을 보면 알 수 있듯이, BPF 코드는 x86 CPU 에서 바로 실행될 수 있는 코드가 아니기 때문에 이를 실행하기 위해서 리눅스 커널은 크게 두 가지 방법을 제공한다. 첫 번째는 간단하지만 실용적이진 않은 인터프리팅 방식이고, 두 번째는 실제로 주로 사용하는 JIT(Just-In-Time) 컴파일 방식이다. 이에 대한 자세한 설명을 하기 전에 잠깐 위와 같은 BPF 코드를 실행한다는 것이 무엇을 의미하는지 살펴보자.\n우리가 어떤 목적을 가지고 개발한 프로그램은 최종적으로 머신코드로 변환되어 실행된다. 여기서 실행된다는 의미는 결국 메모리를 읽어서 필요한 연산을 수행한 다음 메모리에 쓰는 것이고, 메모리는 속도가 느리기 때문에 CPU 내에 있는 레지스터에 필요한 메모리의 값을 복사한 다음 레지스터를 이용하여 연산을 수행하고, 다시 레지스터에 있는 값을 메모리로 복사하는 것이 일반적인 과정이다. 즉, 어떤 코드를 어떤 방식으로 실행했냐가 중요한 것이 아니고, 메모리에서 어떤 값을 읽고, 어떤 연산을 하고, 메모리에 어떤 값을 썼냐가 중요한 것이다. 그렇기 때문에 x86 머신코드로 컴파일해서 x86 CPU 에서 직접 실행하지 않더라도 동일한 방식으로 메모리를 읽고 쓴다면 결과는 동일하다. 이것만 명확히 이해한다면 앞으로 설명할 두 가지 방식도 쉽게 이해할 수 있을 것이다.\n우선 간단히 인터프리팅 방식에 대해 알아보자. 이 방식은 이름 그대로 BPF 코드를 차례대로 읽으면서 실행하는 방식으로, 리눅스 커널에서 아직 JIT 컴파일을 지원하지 않는 CPU 를 사용하거나, 강제로 JIT 컴파일을 막은 경우에만 사용된다. 아래는 리눅스 커널에 포함되어 있는 BPF 인터프리터의 일부분이다.\n\n리눅스 커널 코드답게(?) 매크로가 남발되어 있는 것을 볼 수 있다. 일단 bpf_insn 구조체가 하나의 BPF 명령어를 표현하는 구조체이다. 전체 크기는 64 비트이고, 명령어의 종류를 의미하는 code 필드와 원본 레지스터(src_reg), 목적 레지스터(dst_reg), 그리고 off/imm 상수 필드로 구성되어 있다. 그리고 __bpf_prog_run 함수가 실제로 BPF 명령어를 인터프리팅하는 함수인데, jumptable 배열에 각각의 명령어에 해당하는 라벨이 등록되어 있고 select_insn 라벨에서 현재 명령어의 code 필드를 인덱스로 이용해서 jumptable 배열에 등록되어 있는 라벨로 점프하는 것을 볼 수 있다. 즉, 현재 명령어의 code 필드가 JMP_CALL 에 해당하는 값이면 JMP_CALL 라벨로 점프하여 필요한 작업을 수행하고, 현재 명령어를 다음 명령어로 변경한 다음 select_insn 라벨로 점프(CONT 매크로)하는 반복적인 구조이다.\n앞에서 소개한 filetop의 커널에 로딩된 BPF 코드 중 (0:) 명령어를 인터프리팅 방식으로 어떻게 실행하는지 살펴보자. 해당 명령어의 code 는 0x79 이고, 이는 원본(r1) 레지스터에 오프셋(96)을 더한 주소에 있는 메모리를 읽어서 목적(r2) 레지스터에 저장하라는 뜻이다. 실제 이를 처리하는 커널 코드를 간단히 살펴보자.\n\n0x79 명령어에 해당하는 라벨은 LDX_MEM_DW 이고, 이는 SRC 레지스터(src_reg)에 off 상수값을 더한 주소에 해당하는 메모리의 값을 읽어와서 DST 레지스터(dst_reg)로 저장한다. 여기서 SRC/DST 레지스터는 매크로로 정의되어 있는데, 인터프리팅 방식에서는 실제 CPU 를 이용하는 것이 아니기 때문에 레지스터 또한 변수에 불과하고, 총 10개의 레지스터를 나타내는 배열(regs)을 이용하여 레지스터를 흉내낸다. 즉, SRC 매크로는 레지스터 배열에서 현재 명령어의 원본 레지스터(src_reg)를 의미하고, DST 매크로는 레지스터 배열에서 현재 명령어의 목적 레지스터(dst_reg)를 의미한다.\n이처럼 인터프리팅 방식은 명령어 하나를 처리하기 위해 몇 번의 분기를 하면서 상당히 많은 x86 머신코드를 실행하고, 레지스터도 메모리에 저장되어 있는 변수일뿐이기 때문에 굉장히 느릴 수 밖에 없다. 그래서 이 방식은 실제 사용하기 위한 용도라기 보다는 검증 및 준비 단계에서 사용되는 방식이라고 볼 수 있다.\n이제 JIT 컴파일 방식에 대해 알아보자. 이 방식은 간단히 말하면 미리 BPF 코드를 x86 머신코드로 변환해놓고, BPF 프로그램이 실행될때마다 미리 변환해놓은 x86 머신코드를 바로 실행하는 것이다. 아래는 리눅스 커널에 포함되어 있는 BPF-to-x86 JIT 컴파일러의 일부분이다.\n\n위의 do_jit 함수는 리눅스 커널에서 BPF 코드를 x86 머신코드로 JIT 컴파일하는 함수이다. 기본적인 동작 원리는 적당한 크기의 버퍼를 미리 생성해놓고 BPF 코드를 하나씩 x86 머신코드로 변환하면서 버퍼를 순서대로 채워나가는 방식이다.\n우선, 가장 간단한 레지스터에 상수값을 저장하는 명령어가 어떻게 변환되는지 살펴보자. 아래는 상수값을 레지스터에 저장하는 (2:) 명령어가 x86 머신코드로 변환된 결과를 보여주고 있다.\n\n상수값을 레지스터에 저장하는 명령어의 코드는 BPF_ALU64 | BPF_MOV | BPF_K (0xb7) 이다. do_jit 함수에서 해당 케이스를 살펴보면, emit_mov_imm32 함수를 호출하는데, 해당 함수에서는 상수값을 레지스터에 저장하는 x86 명령어의 코드인 0xb8 과 r3 레지스터에 해당하는 edx 레지스터와 상수값(1)을 이용하여 x86 머신코드를 버퍼에 추가하는 것을 볼 수 있다. 인터프리팅 방식과 달리 JIT 컴파일러는 실제 x86 CPU 에서 바로 실행될 수 있는 x86 머신코드를 생성하기 때문에 BPF 코드의 레지스터를 x86 CPU 에서 바로 사용가능한 레지스터로 변환한다. 이 레지스터 할당은 위의 reg2hex 배열에 선언된 것처럼 1:1 로 매칭되기 때문에 오버헤드 없이 진행이 가능하다. 즉, JIT 컴파일 방식은 BPF 코드를 x86 머신코드로 미리 변환해놓고, x86 CPU 레지스터도 바로 할당해서 사용하기 때문에 인터프리팅 방식에 비해 월등히 성능이 좋을 수 밖에 없다.\n다음으로, 메인함수(vfs_write_entry)에서 공통함수((probe_entry)를 호출하는 명령어가 어떻게 변환되는지 살펴보자. 아래는 해당 명령어가 x86 머신코드로 변환된 결과를 보여주고 있다.\n\n함수를 호출하는 명령어의 코드는 BPF_JMP | BPF_CALL (0x85) 이다. do_jit 함수에서 해당 케이스를 살펴보면, 호출되는 공통함수의 주소를 __bpf_call_base + imm32 로 설정하는 부분이 있다. 이는 리눅스 커널에서 함수별로 따로 JIT 컴파일을 수행하므로 공통함수를 JIT 컴파일한 버퍼의 주소가 필요하기 때문인데, 함수호출 명령어에서 이 주소를 4 바이트 크기의 상수(imm)로 표현하기 위해 64 비트 절대주소가 아닌, 기준함수(__bpf_call_base)에서의 상대주소(오프셋)로 표현하고, 메인함수를 JIT 컴파일하는 동안 다시 기준함수를 이용하여 32 비트 상대주소를 64 비트 절대주소로 변환해서 사용한다. 그래서 emit_call 함수에서 현재 컴파일 중인 명령어의 64 비트 절대주소가 확정되면, 공통함수의 버퍼의 절대주소와 현재 명령어의 절대주소를 이용하여 현재 명령어에서 공통함수까지의 거리(오프셋)를 구하여 공통함수를 호출하는 x86 머신코드를 생성한다. 즉, JIT 컴파일된 함수호출 명령어(18:)의 0x20c8 은 해당 명령어에서 공통함수의 버퍼까지의 거리를 의미하기 때문에 BPF 프로그램을 컴파일할 때마다 값이 다를 것이다.\n여기까지 리눅스 커널에서 BPF 코드를 실행하는 과정에 대해 살펴보았다.\n","description":"","id":"https://haruband.github.io/ebpf-loading-jit/","title":"[eBPF] BPF 실행파일 로딩 과정 분석 (JIT)"},"https://haruband.github.io/ebpf-loading-memory/":{"body":"BPF 는 일반적인 프로그램과 유사한 방식으로 개발하기 때문에 유사한 실행파일 및 메모리 구조를 가지고 있지만, 커널 안에서 제한된 환경으로 실행되기 때문에 로딩(loading)하는 과정은 상당히 다르다. 오늘은 BPF 의 실행파일 및 메모리 구조에 대해 간단히 살펴본 후, 이를 로딩하는 과정에 대해 분석해보도록 하자.\n일반적인 실행파일에서 가장 중요한 두 가지는 코드와 데이터이다. 코드는 말그대로 상위언어를 컴파일한 머신코드를 의미하고, 데이터는 실행시 코드가 참조하는 메모리를 의미한다. 데이터는 스택과 힙같이 실행시 메모리가 할당/해제되는 동적 데이터와 전역변수처럼 코드에서 선언되는 정적 데이터로 나뉘는데, 정적 데이터는 실행파일을 로딩할 때 메모리가 할당되고 해당 메모리를 참조하는 코드도 재배치(relocation)된다. 그리고 정적 데이터는 크게 읽기전용 변수, 초기화된 전역변수 그리고 초기화되지 않은 전역변수로 구분되는데, 아래 코드(bcc 의 runqslower 예제코드를 약간 변형한 것이다)를 보면서 조금 더 설명하도록 하겠다.\n\n우선 읽기전용 변수는 rodata0 처럼 const 로 선언된 전역변수를 의미하고, 해당 메모리에 대한 쓰기 작업을 금지하기 위해 읽기전용의 페이지를 할당받아 사용한다. 그리고 data0 과 data1 같이 초기값을 가지고 있는 전역변수는 초기화된 전역변수로 분류되고, bss0 과 같이 초기값을 가지고 있지 않은 전역변수는 초기화되지 않은 전역변수로 분류된다. 아래는 위의 예제코드를 컴파일한 후 objdump 를 이용해서 섹션 테이블과 심볼 테이블을 출력한 것이다.\n\n리눅스에서 주로 사용하는 ELF 실행파일 구조이고, 용도에 따라 다양한 섹션으로 구성되어 있다. 심볼 테이블을 보면 읽기전용 변수인 rodata0 은 읽기전용 데이터 섹션인 .rodata 에 속해있고, 초기화된 전역변수인 data0 과 data1 은 .data 섹션에, 그리고 초기화되지 않은 전역변수인 bss0 은 .bss 섹션에 포함되어 있는 것을 볼 수 있다. 여기서 .data 섹션과 .bss 섹션의 차이점은 .data 섹션은 실제 초기값들을 실행파일 안에 포함하고 있지만, .bss 섹션은 초기값이 없기 때문에 실행파일 안은 비어있고 로딩 시에 메모리를 할당받은 후 0 으로 초기화한다.\n일반적인 프로그램을 실행할 때는 .data, .rodata, 그리고 .bss 섹션까지 프로세스의 가상 주소 공간에 필요한 메모리를 할당받아 실행파일로부터 필요한 데이터를 복사한 후 로딩 작업을 마무리하지만, BPF 는 커널 주소 공간에서 실행되기 때문에 강도 높은 안정성과 보안성을 위해 다른 방식으로 로딩 작업을 진행한다. 이후 자세한 로딩 과정은 libbpf를 기준으로 설명하도록 하겠다.\n우선, BPF 실행파일의 .data, .rodata, 그리고 .bss 섹션을 각각 BPF 맵(map)으로 만든다. BPF 맵은 사용자 코드와 BPF 코드가 데이터를 공유하는 가장 보편적인 방식으로, .data 와 .rodata 섹션은 BPF 맵을 만든 다음 실행파일의 각 섹션에 있는 데이터를 복사하고, .bss 섹션은 0 으로 초기화되어 있는 BPF 맵을 만든다. 그리고 각 섹션에 있는 변수를 참조하는 코드를 재배치해야 하는데, 우선 앞의 예제에서 data1 변수를 참조하는 부분의 코드를 살펴보자.\n\n위의 (11:) 명령어는 data1 에 있는 값을 r2 레지스터로 복사하는 부분인데, opcode 와 레지스터 정보만 있고 다른 모든 값은 0 으로 채워져있다. 이는 커널에 BPF 코드를 넘기기 전에 아래의&nbsp;재배치 정보를 이용하여 필요한 다른 값으로 채워진다.\n\n위의 재배치 목록의 첫 번째 항목은 tp_btf/sched_switch 섹션(handle__sched_switch 함수)의 오프셋이 0x58 인, (11:) 명령어에서 data1 변수를 참조하고 있다는 의미이다. 이 명령어는 보는 것처럼 8 바이트씩 2 개의 명령어로 구성되어 있는데, 재배치 과정에서 첫 번째 명령어에는 data1 변수가 속해있는 섹션(.data)으로 만들어진 BPF 맵의 파일디스크립터를 집어넣고, 두 번째 명령어에는 data1 변수가 속해있는 섹션에서의 오프셋을 집어넣는다. 아래는 필자가 사용 중인 서버에서 앞의 예제를 실행한 프로세스의 파일디스크립터 정보를 출력한 것이다.\n\n해당 프로세스의 파일디스크립터 목록 중 6 번이 .data 섹션에 해당하는 BPF 맵이기 때문에 (11:) 명령어의 첫 번째 명령어에는 6 이라는 값이 채워지고, 심볼 테이블을 보면 data1 변수는 .data 섹션에서 오프셋이 4 이기 때문에 (11:) 명령어의 두 번째 명령어에는 4 라는 값이 채워진다. 이러한 재배치 과정을 통해 나온 BPF 코드는 아래와 같다.\n\n우선 현재 사용 중인 BPF 맵 목록을 보면 각 섹션(.data, .rodata, .bss)에 해당하는 BPF 맵에 대한 정보를 볼 수 있다. 각각의 BPF 맵은 1개의 요소만을 가지는 arraymap 형태로 만들어지고, 배열 요소의 크기는 각 섹션의 크기와 동일하다. 그리고 위의 커널에 로딩된 BPF 코드를 살펴보면, (11:) 명령어에서 파일디스크립터(6)에 해당하는 BPF 맵의 ID(8105)와 첫 번째 배열 요소를 나타내는 인덱스(0), 그리고 해당 배열 요소에서의 오프셋(4)을 볼 수 있다.\n이러한 재배치 작업이 끝난 후, 커널에서는 파일디스크립터와 오프셋을 이용하여 실제 메모리 주소를 구한 다음, (11:) 명령어의 첫 번째 명령어에 해당 메모리 주소의 하위 32 비트 주소를 저장하고, 두 번째 명령어에 상위 32 비트 주소를 저장한다. 마지막으로 BPF 코드를 실제 동작 가능한 머신코드(x86)로 JIT(Just-In-Time) 컴파일한 결과물은 아래와 같다.\n\n위의 (4b:) 명령어를 보면 x86 CPU 에서 r2 레지스터에 해당하는 rsi 레지스터가 할당되어 있는 것과 재배치 작업이 끝난 data1 의 메모리 주소가 들어가 있는 것을 볼 수 있다. 여기까지 BPF 코드에서 전역변수로 선언된 data1 에 접근하기 위해 필요한 재배치 과정을 살펴보았다.\n","description":"","id":"https://haruband.github.io/ebpf-loading-memory/","title":"[eBPF] BPF 실행파일 로딩 과정 분석 (메모리 재배치)"},"https://haruband.github.io/ebpf-loading-program/":{"body":"BPF 는 일반적으로 하나의 함수(메인함수)가 하나의 섹션이 되고, 하나의 섹션이 하나의 프로그램이 된다. 그래서 커널에서 해당 프로그램을 실행할 때는 프로그램의 시작 위치가 메인함수의 시작 위치이기 때문에 간단히 처음부터 실행하면 된다. 하지만 아래와 같이 메인함수에서 공통함수를 호출하는 경우처럼 두 개 이상의 함수가 필요한 경우에는 프로그램의 시작 위치를 어떻게 보장할까? 메인함수를 무조건 프로그램의 시작 위치에 배치할까? 아니면 메인함수가 어디에 위치하든 프로그램의 시작 위치를 메인함수의 시작 위치로 지정할까? BPF 는 이를 해결하기 위해 서브프로그램이라는 기능을 제공하고 있고, 오늘은 이에 대해 살펴보도록 하자.\n\n위의 코드는 bcc 의 filetop 예제코드이다. 해당 예제는 vfs_read 와 vfs_write 커널함수에서 각각 사용할 두 개의 BPF 메인함수와 두 개의 함수에서 사용하는 공통함수(probe_entry)로 구성되어 있다. 이를 컴파일한 결과는 아래와 같다.\n\n위의 오브젝트를 보면 메인함수는 각각의 섹션에 위치해있지만 공통함수는 .text 섹션에 위치해있는 것을 볼 수 있다. (함수 선언 앞에 섹션을 지정하지 않으면 해당 함수는 기본적으로 .text 섹션에 위치하게 된다.) 일반적으로 BPF 프로그램을 로딩할 때는 하나의 특정 섹션을 지정해서 사용하는데, 위와 같이 메인함수에서 호출하는 함수가 다른 섹션에 존재할 때는 어떻게 동작하는 것일까? 이 질문에 대한 해답은 libbpf를 기준으로 설명하도록 하겠다. 우선 아래 재배치 목록을 살펴보자.\n\n위의 재배치 목록 중 두 번째 항목은 kprobe/vfs_write 섹션의 0x18 오프셋에 해당하는 (3:) 명령어에서 .text 섹션을 참조한다는 의미이다. 그리고 kprobe/vfs_write 섹션의 (3:) 명령어의 인자를 보면 -1 (0xffffffff) 인 값인데, 이는 해당 섹션(.text)에서 -1 에 1 을 더한 위치를 의미한다. 즉, (3:) 명령어는 .text 섹션의 0x0 오프셋을 호출(call)하라는 뜻이다. 이러한 재배치 정보를 이용하여 실제 커널에 전달할 BPF 코드를 작성하는 과정은 다음과 같다.\n\n일단 심볼 테이블을 이용하여 코드를 포함하고 있는 섹션에 있는 함수들을 모두 프로그램으로 등록한다. 위의 심볼 테이블을 보면, kprobe/vfs_read 섹션에 있는 vfs_read_entry 함수를, kprobe/vfs_write 섹션에 있는 vfs_write_entry 함수를, 그리고 .text 섹션에 있는 probe_entry 함수를 각각 프로그램으로 등록한다. 이때 .text 섹션에 있는 함수들은 모두 서브프로그램으로 등록이 되는데, 이는 커널에 직접 로딩되는 프로그램이 아니고, 다른 프로그램에서 호출해서 사용하는 프로그램이라는 의미이다. 그리고 나머지 커널에 직접 로딩되는 프로그램들은 앞의 재배치 정보(.text 섹션의 0x0 오프셋)와 프로그램 목록(.text 섹션의 0x0 오프셋에 해당하는 probe_entry 프로그램)을 이용하여 메인함수에서 호출하는 함수를 해당 프로그램의 뒤쪽에 추가하고, 해당 함수를 호출하는 명령어의 인자를 적절한 값으로 수정한다. 이 과정은 메인함수에서 호출한 함수에서도 다른 함수를 호출할 수 있기 때문에 재귀적으로 일어난다. 아래는 커널에 로딩된 프로그램(BPF 코드)을 덤프한 것이다.\n\n위의 코드를 보면, 맨 앞 부분에 메인함수가 위치해있고, 바로 이어서 공통함수(probe_entry)가 위치해있는 것을 볼 수 있다. 그리고 공통함수를 호출하는 (3:) 명령어를 보면, 공통함수의 시작 위치가 (6:) 명령어이기 때문에 다음 명령어(4:)의 주소값(Program Counter)을 기준으로 2 를 더한 위치를 호출하는 것을 볼 수 있다. 마지막으로 BPF 코드를 실제 동작 가능한 머신코드(x86)로 JIT(Just-In-Time) 컴파일한 결과물은 아래와 같다.\n\n리눅스 커널에서는 앞의 BPF 코드를 한번에 컴파일하지 않고, 메인함수와 공통함수를 서브프로그램으로 나눈 다음 각각 컴파일한다. 그리고 메인함수(vfs_write_entry)에서 공통함수(probe_entry)를 호출하는 명령어(18:)를 보면, 다음 명령어(0x1d:)의 위치에서 공통함수를 JIT 컴파일한 결과물이 저장된 메모리 위치까지의 거리(오프셋)를 이용하여 호출하는 것을 볼 수 있다. 여기까지 BPF 코드에서 다른 함수를 호출하는 과정을 살펴보았다.\n","description":"","id":"https://haruband.github.io/ebpf-loading-program/","title":"[eBPF] BPF 실행파일 로딩 과정 분석 (서브프로그램)"},"https://haruband.github.io/images/":{"body":"","description":"","id":"https://haruband.github.io/images/","title":""},"https://haruband.github.io/k8s-cgroupv2-privatens/":{"body":"최근 공개된 우분투 21.10 은 컨테이너와 관련된 상당히 큰 부분이 변경되었다. 마침내 CGroupV2 가 적용되었고, 도커도 업그레이드되면서 CGroup 네임스페이스의 기본값이 Private 으로 설정되었다. 오늘은 이로 인해 발생한 문제에 대해 자세히 살펴보도록 하자.\n어떠한 문제가 발생했는가???\n개발 서버에 우분투 21.10 을 설치한 후, 늘 쓰던대로 쿠버네티스와 Cilium 을 설치하였는데 갑자기 서비스가 정상동작하지 않는 문제가 발생하였다. 몇 가지를 확인해 본 후, 파드 네임스페이스와 호스트 네임스페이스 모두에서 파드의 ClusterIP 로는 통신이 되는데, 서비스의 ClusterIP 로는 통신이 되지 않는 현상을 발견하였다. 그래서 tcpdump 로 패킷을 확인해보니 서비스의 ClusterIP 가 소켓 기반 로드밸런싱을 통해 파드의 ClusterIP 로 변경되지 않고 그대로 남아있었다. 즉, 소켓 기반 로드밸런싱이 제대로 작동하지 않는 문제였다.\n어떻게 문제가 발생했는가???\n문제의 원인은 비교적 쉽게 파악하였는데, 아래 쿠버네티스 노드의 모든 CGROUP 에 연결된 BPF 프로그램 목록을 살펴보자.\n\n소켓 기반 로드밸런싱에 사용되는 BPF 프로그램이 루트 CGROUP 이 아닌 특정 컨테이너의 하위 CGROUP 에 연결되어 있었다. 그리고 아래 출력을 보면 알 수 있듯이, 해당 컨테이너는 다름 아닌 Cilium 에이전트 컨테이너였다. 이는 심각한 문제를 발생시키는데, 이유는 소켓 시스템콜은 자신이 속한 CGROUP 만이 아니라 루트 CGROUP 까지 모든 부모 CGROUP 에 연결된 BPF 프로그램을 실행하므로 Cilium 에이전트는 간단히 루트 CGROUP 에만 필요한 BPF 프로그램을 연결하여 소켓 기반 로드밸런싱을 처리하기 때문이다.\n\n이와 같은 문제가 발생한 이유는, 소켓 기반 로드밸런싱에 사용되는 BPF 프로그램은 Cilium 에이전트에서 CGroupV2 파일시스템을 /run/cilium/cgroupv2 디렉토리에 마운트한 후 루트 CGROUP 인 최상위 디렉토리에 연결하는데, 우분투 21.10 에서는 도커의 CGroup 네임스페이스의 기본값이 Private 으로 변경되어 최상위 디렉토리가 루트 CGROUP 이 아닌 해당 컨테이너의 CGROUP 이 되었기 때문이다.\n어떻게 문제를 해결했는가???\n가장 간단한 해결책은 도커의 CGroup 네임스페이스의 기본값을 Host 로 변경해버리는 것이겠지만, 이보다는 Cilium 에서 추천하는 해결책을 소개하도록 하겠다. 이는 현재 Cilium 의 Helm 차트에 적용되어 있는 방법이다.\n\n위는 Helm 차트에 적용되어 있는 Cilium 에이전트의 데몬셋의 일부이다. 언급된 문제를 해결하기 위해 mount-cgroup 이라는 initContainer 가 추가되어 있으며, 이는 nsenter 를 이용하여 호스트 네임스페이스의 1번 프로세스의 CGroup 과 Mount 네임스페이스로 변경 후 /run/cilium/cgroupv2 디렉토리에 CGroupV2 파일시스템을 마운트한다. 즉, 호스트 파일시스템의 /run/cilium/cgroupv2 디렉토리에 최상위 네임스페이스의 CGroupV2 파일시스템이 마운트된 것이다. 그리고 Cilium 에이전트 컨테이너에서는 hostPath 를 이용하여 호스트 파일시스템의 /run/cilium/cgroupv2 디렉토리를 그대로 사용하면 해당 문제는 완벽히 해결된다.\n앞에서 언급한 해결책을 적용한 다음 쿠버네티스 노드의 모든 CGROUP 에 연결된 BPF 프로그램 목록을 살펴보자.\n\n위에서 보는 것처럼, 루트 CGROUP 에 소켓 기반 로드밸런싱에서 필요로 하는 모든 BPF 프로그램이 연결되어 있는 것을 볼 수 있다.\n","description":"","id":"https://haruband.github.io/k8s-cgroupv2-privatens/","title":"[K8S] Cilium CGroupV2/PrivateNS 문제 분석"},"https://haruband.github.io/k8s-cni-dsr/":{"body":"Cilium 에서는 외부에서 쿠버네티스 서비스에 접근할 때 사용되는 NodePort, LoadBalancer 등의 성능을 개선할 수 있는 DSR(Direct Server Return) 기능을 제공한다.\n\n위 그림처럼 DSR 의 목적은 파드(nginx)의 응답 패킷을 다시 Node0 을 통해 클라이언트로 전달하는 것이 아니고, Node1 에서 바로 클라이언트로 전달하겠다는 것이다. 이를 통해 Node1 에서 Node0 으로 응답 패킷을 전송하는 비용을 줄일 수 있다.\n그럼 DSR 을 이용해서 패킷이 전달되는 과정을 좀 더 상세히 살펴보도록 하자.\n클라이언트에서 Node0 으로 전송된 패킷은 물리 네트워크 장치의 ingress BPF 프로그램(cilium/bpf/bpf_host.c#from-netdev)에 의해 목적지 주소(172.26.50.101:30645)를 백엔드 주소(10.0.1.72:80)로 변환한다. (Node0 으로 응답 패킷이 다시 전달되는 것이 아니기 때문에 conntrack 맵에 변환정보를 저장하진 않는다.) 그리고 해당 패킷을 Node1 로 전달하는데, Node1 에서 클라이언트로 응답 패킷을 전달할 때 출발지 주소를 원래 클라이언트가 접속한 주소로 변환하기 위해 원래의 목적지 주소(172.26.50.101:30645)를 IP 의 옵셥(option) 헤더에 추가한다.\nNode1 의 물리 네트워크 장치로 수신된 패킷은 파드(nginx)의 ingress BPF 프로그램(cilium/bpf/bpf_lxc.c#handle_policy)에서 전달받은 IP 의 옵션 헤더에 저장된 원래의 목적지 주소(172.26.50.101:30645)를 cilium_snat_v4_external 맵에 저장해놓고, conntrack 맵에 변환정보를 추가한다. 그리고 파드(nginx)에서 응답 패킷을 만들어 전송하면 파드(nginx)의 egress BPF 프로그램(cilium/bpf/bpf_lxc.c#from-container)에서 conntrack 맵에 저장된 정보를 이용하여 cilium_snat_v4_external 맵에서 필요한 정보를 가져와서 응답 패킷의 출발지 주소를 원래 클라이언트가 접속했던 목적지 주소(172.26.50.101:30645)로 변환한다. 이러한 과정을 거쳐 클라이언트는 패킷을 보낸 주소 그대로 패킷을 받게 되는 것이다.\n여기까지 Cilium 에서 DSR 기능을 이용하여 Client-To-NodePort 통신이 이루어지는 과정을 살펴보았다.\n","description":"","id":"https://haruband.github.io/k8s-cni-dsr/","title":"[K8S/Cilium] DSR (Direct Server Return)"},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"body":"Cilium 에서 제공하는 IPVLAN 기반의 Routing Datapath 기법을 사용하던 중 NodePort 관련 버그를 발견하였다. (NodePort 는 모든 노드의 지정된 포트로 접속하면 백엔드(선택된 파드)로 연결해주는 서비스이다.) IPVLAN 을 사용하는 경우, 접속한 노드에 백엔드가 없는 경우는 잘 동작하지만 접속한 노드에 백엔드가 있는 경우는 동작하지 않는 문제가 발생했다. 왜 이런 문제가 발생하였는지 자세히 살펴보도록 하자.\n아래 그림은 정상적으로 잘 동작하고 있는 VXLAN 기반의 Cilium 에서 NodePort 가 동작하는 과정을 보여주고 있다. 오른쪽은 다른 노드에 백엔드가 있는 경우이고, 왼쪽은 같은 노드에 백엔드가 있는 경우이다.\n\n우선, 다른 노드에 백엔드가 있는 경우는, 클라이언트가 NodePort 로 접속하면 호스트 네트워크 디바이스에 연결된 ingress BPF 프로그램(cilium/bpf/bpf_host.c#from-netdev)에서 목적지 주소를 백엔드 주소로 변환(DNAT)하고 출발지 주소를 해당 노드의 주소로 변환(SNAT)한 다음, 백엔드가 있는 노드로 패킷을 전달한다. 그리고 응답 패킷을 받으면 호스트 네트워크 디바이스에 연결된 ingress BPF 프로그램에서 목적지 주소를 클라이언트의 주소로 변환하고 출발지 주소를 해당 노드의 주소로 변환한 다음, 클라이언트에게 패킷을 전달한다.\n다음으로, 같은 노드에 백엔드가 있는 경우는, 클라이언트가 NodePort 로 접속하면 호스트 네트워크 디바이스에 연결된 ingress BPF 프로그램(cilium/bpf/bpf_host.c#from-netdev)에서 목적지 주소를 백엔드 주소로 변환(DNAT)한 다음, 바로 해당 백엔드 주소를 사용하는 Pod0 의 veth0 으로 패킷을 전달(redirect)한다. 그리고 Pod0 이 응답 패킷을 전달하면 Pod0 의 veth0 에 연결된 ingress BPF 프로그램(cilium/bpf/bpf_lxc.c#from-container)에서 출발지 주소를 해당 노드의 주소로 변환한 다음, 클라이언트에게 패킷을 전달한다.\n이제 IPVLAN 기반의 Cilium 에서 NodePort 가 동작하는 과정을 살펴보자. 위와 마찬가지로 오른쪽은 다른 노드에 백엔드가 있는 경우이고, 왼쪽은 같은 노드에 백엔드가 있는 경우이다.\n\n우선, 다른 노드에 백엔드가 있는 경우는 VXLAN 과 동일한 방식으로 잘 동작한다. 요청 패킷과 응답 패킷 모두 호스트 네트워크 디바이스에 연결된 ingress BPF 프로그램에서 처리하기 때문에 아무 문제없이 동작한다. 하지만 같은 노드에 백엔드가 있는 경우는 VXLAN 과 동일한 방식으로 동작하는 것처럼 보이지만 중요한 차이점이 있는데, 그건 바로 Pod0 의 응답 패킷을 Pod0 의 eth0 에 연결된 egress BPF 프로그램에서 처리한다는 것이다. 위의 그림을 자세히 보면 호스트의 ingress BPF 프로그램에서 Pod0 의 eth0 으로 패킷을 전달할 때 VXLAN 과 달리 redirect 를 사용하지 않고, 그냥 pass 를 하는 것이 보일 것이다. (redirect 는 리눅스 커널이 제공하는 bpf_redirect() 함수를 이용하여 원하는 네트워크 장치로 패킷을 바로 전달하는 것이고, pass 는 네트워크 스택을 거쳐 자연스럽게 패킷을 전달하는 것이다.) 이는 동일한 네트워크 네임스페이스에 존재하는 장치로만 redirect 를 사용할 수 있는데, 호스트 네트워크 디바이스와 Pod0 의 eth0 은 서로 다른 네트워크 네임스페이스에 있기 때문이다. 그래서 Pod0 의 eth0 에 연결된 egress BPF 프로그램에서도 호스트로 응답 패킷을 전달할 때 redirect 를 사용하지 않고 pass 를 해야하는데, 현재 Cilium 에서는 redirect 를 사용해서 이런 문제가 발생한 것이다.\n여기까지 IPVLAN 기반의 Cilium 에서 NodePort 를 처리하는 과정에서 발생한 버그에 대해 자세히 살펴보았다.\n","description":"","id":"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/","title":"[K8S/Cilium] IPVLAN 기반 Cilium 의 NodePort 버그 분석"},"https://haruband.github.io/k8s-cni-ipvlan/":{"body":"Cilium 은 IPVLAN 에 기반한 Routing Datapath 기법을 제공하고 있다. IPVLAN 은 VXLAN 과 마찬가지로 리눅스 커널이 제공하는 기능이므로 IPVLAN 에 대한 자세한 설명은 생략하고, Cilium 의 동작 과정을 설명하면서 필요한 부분에 대해서만 간단히 부연설명하겠다. (Routing Datapath 기법은 모든 노드가 같은 서브넷 안에 있을 때만 사용 가능하다. Calico 는 같은 서브넷에서는 라우팅 기법을, 다른 서브넷에서는 터널링 기법을 사용하는 CrossSubnet 기능도 제공하지만, Cilium 에는 아직 이러한 기능은 없다.)\n아래 그림은 Cilium 에서 IPVLAN 을 사용할 경우 Pod-To-Pod 통신이 이루어지는 과정이다. Node0 의 Pod0 에서 Node1 의 Pod3 으로 패킷을 보내는 과정을 살펴보도록 하자.\n\n기본적으로 VETH/VXLAN 에 비해 구조가 단순한데, 그 이유는 파드의 eth0 은 IPVLAN 슬레이브로, Node 의 eth0 은 IPVLAN 마스터로 동작하기 때문이다. IPVLAN 슬레이브에서 패킷을 전송하면 IP 헤더를 확인하여 동일한 노드에 해당 목적지 주소를 사용하는 IPVLAN 슬레이브가 있으면 바로 전달하고, 아니면 IPVLAN 마스터로 패킷을 전달한다.\nIPVLAN 은 MACLAN 과 달리 모든 슬레이브가 마스터의 맥 주소를 공유한다. 즉, MACLAN 처럼 마스터 네트워크 장치를 Promiscuous 모드로 사용하거나, 스위치의 물리적인 제한에 걸리는 문제가 없다는 말이다. 아래는 IPVLAN 기반의 Cilium 을 사용할 경우 파드와 노드의 네트워크 정보이다.\n\nIPVLAN 을 사용하는 경우, LXC BPF 프로그램(cilium/bpf/bpf_lxc.c)을 연결하는 것이 애매하다. VXLAN 을 사용하는 경우에는 파드의 veth 가 호스트 네트워크 네임스페이스에 존재하기 때문에 veth 에 LXC BPF 프로그램을 연결해서 사용하지만, IPVLAN 은 호스트 네트워크 네임스페이스에 추가적인 가상 네트워크 장치가 없기 때문에 파드의 eth0 에 LXC BPF 프로그램을 연결할 수 밖에 없다. (Kubelet 과 Cilium 이 호스트 네트워크 네임스페이스에서 동작하기 때문에 LXC BPF 프로그램을 연결할 가상 네트워크 장치가 같은 호스트 네트워크 네임스페이스에 있는 것이 편리하다.) 이 문제를 해결하기 위해 Cilium 은 호스트 네임스페이스에 각각의 파드를 위한 BPF 프로그램 어레이 맵을 하나씩 만들고, 파드의 eth0 의 egress 에는 해당 BPF 프로그램 어레이 맵의 첫 번째 프로그램을 tailcall 하는 프로그램을 연결하는 방식을 사용하고 있다.\n\n위 함수는 Kubelet 에서 새로운 파드를 생성할 때 호출하는 cilium-cni 에서 파드를 위한 IPVLAN 슬레이브(eth0)를 만들고 해당 슬레이브의 egress 에 실제로 연결할 프로그램을 생성하는 함수이다. fd 인자가 바로 앞에서 언급한 호스트 네임스페이스에서 생성한 BPF 프로그램 어레이 맵에 접근할 수 있는 파일디스크립터이고, fd 와 0 을 인자로 tailcall 명령어를 호출하는 간단한 프로그램을 반환한다. 이런 준비과정을 거쳐 Cilium 은 파드의 LXC BPF 프로그램을 변경하고 싶을 때 네임스페이스 변경없이 앞에서 생성한 BPF 프로그램 어레이 맵의 첫 번째 프로그램을 변경만 하면 되는 것이다. 그리고 ingress 는 가상 네트워크 장치에 LXC BPF 프로그램을 직접 연결하는 방식이 아니기 때문에 VXLAN 과 동일한 방식을 사용한다. (cilium_call_policy 맵에 목적지(파드)의 엔드포인트 아이디를 인덱스로 사용해서 저장된 프로그램(cilium/bpf/bpf_lxc.c#handle_policy)을 tailcall 로 직접 호출한다.)\n참고로, 동일한 LXC BPF 프로그램(cilium/bpf/bpf_lxc.c#from-container)이 IPVLAN 에서는 파드의 eth0 의 egress 에 연결되지만, VXLAN 에서는 veth 의 ingress 에 연결된다. 이는 VXLAN 에서는 파드의 eth0 의 TX 가 veth 의 RX 로 바로 전달되기 때문에 호스트 네임스페이스에 있는 veth 의 ingress 에 연결하는 것이다.\nIPVLAN 슬레이브에 연결된 BPF 프로그램이 호스트 네임스페이스에서 동작하지 않기 때문에 호스트 네임스페이스에 있는 IPVLAN 마스터로 패킷을 직접 전달(redirect)하는 것은 불가능하다. BPF 프로그램에서 패킷을 전달(redirect)할때 네트워크 장치 인덱스를 같이 전달하는데, 기본적으로 동일한 네임스페이스에 있는 장치 목록에서만 검색을 하기 때문에 다른 네임스페이스에 있는 장치로 패킷을 전달(redirect)하는 것은 불가능하다. 하지만 IPVLAN 은 슬레이브에서 패킷을 내보내면(xmit) IPVLAN 드라이버에서 마스터로 직접 전달해주기 때문에 슬레이브에 연결된 BPF 프로그램에서는 패킷을 전달(redirect)하는 대신, 전송(xmit)만하면 된다. 동일한 노드에 있는 다른 슬레이브로 패킷을 전달할 때도 IPVLAN 드라이버에서 목적지 주소를 확인해서 해당 슬레이브로 패킷을 바로 전달해준다. (반대로, IPVLAN 마스터에서 슬레이브로 패킷을 전달할 때도 전달(redirect)하는 대신, 전송(xmit)하면 IPVLAN 드라이버에서 목적지 주소를 확인해서 해당 슬레이브로 패킷을 바로 전달해준다.)\n그럼 이제 패킷이 전달되는 과정을 좀 더 상세히 살펴보도록 하자.\nNode0 의 Pod0&nbsp;에서 생성된 패킷은 eth0 의 ingress BPF 프로그램(cilium/bpf/bpf_lxc.c#from-container)에 의해 목적지 주소가 동일한 노드이면 해당 목적지(Pod1)의 eth0 으로 바로 전송(xmit)하고, 다른 노드이면 노드의 eth0 으로 전송(xmit)한다. 노드에서는 일반적인 패킷과 동일한 방식으로 라우팅 테이블을 참고하여 패킷을 전달하는데, 이는 새로운 노드가 추가될때 해당 노드의 PodCIDR 과 주소를 이용해서 아래와 같이 라우팅 정보를 미리 추가해놓기 때문에 가능하다. (이처럼 Routing Datapath 기법은 모든 노드가 같은 서브넷에 있으면 각 노드의 주소를 게이트웨이 주소로 사용해서 터널링 없이 라우팅이 가능하다.)\n\nNode1 의 물리 네트워크 장치(eth0)로 수신된 패킷은 ingress BPF 프로그램(cilium/bpf/bpf_host.c#from-netdev)에서 처리된다. 여기서는 목적지 주소가 해당 노드에 있으므로 cilium_call_policy 맵에 목적지(Pod3)의 엔드포인트 아이디를 인덱스로 사용해서 저장된 프로그램(cilium/bpf/bpf_lxc.c#handle_policy)을 tailcall 로 호출하여 필요한 처리를 한 뒤, 목적지(Pod3)의 eth0 으로 패킷을 전송(xmit)한다.\n여기까지 IPVLAN 을 통해 Pod-To-Pod 통신이 이루어지는 과정을 살펴보았다.\n","description":"","id":"https://haruband.github.io/k8s-cni-ipvlan/","title":"[K8S/Cilium] IPVLAN 기반 Routing Datapath 기법"},"https://haruband.github.io/k8s-cni-loadbalancing/":{"body":"Cilium 에서 ClusterIP 서비스로 통신할때 로드밸런싱이 이루어지는 과정은 아래 그림과 같다. 왼쪽 그림은 네트워크 기반 로드밸런싱 방식이고, 오른쪽 그림은 소켓 기반 로드밸런싱 방식이다. 간단한 설명을 위해 백엔드가 같은 노드에 있는 경우만 살펴보자.\n\n우선 왼쪽의 네트워크 기반 로드밸런싱을 살펴보면, Pod1 에서 생성된 패킷은 호스트 네임스페이스에 있는 veth1 의 ingress BPF 프로그램(cilium/bpf/bpf_lxc.c#from-container)에서 모두 처리되는데, 이때 목적지 주소가 서비스 주소(10.10.8.55)이면 해당 서비스의 백엔드 주소 중 하나(10.0.0.31)로 변환(DNAT)한 다음 패킷을 전달한다. 그리고 백엔드에서 응답 패킷이 오면 veth1 의 egress BPF 프로그램(cilium/bpf/bpf_lxc.c#handle_policy)에서 출발지 주소(10.0.0.31)를 원래의 서비스 주소(10.10.8.55)로 변환한 다음 Pod1 에게 응답 패킷을 전달하게 된다.\n이 방식은 모든 패킷을 송수신할 때마다 DNAT 변환 및 역변환 과정을 거쳐야하기 때문에 오버헤드가 발생한다. 이를 해결하기 위해 나온 것이 바로 오른쪽의 소켓 기반 로드밸런싱이다.\n소켓 기반 로드밸런싱은 그림에서 볼 수 있는 것처럼 굉장히 단순한데, Pod1 안에서 동작하는 앱이 connect() 시스템콜을 이용하여 소켓을 연결할 때 목적지 주소가 서비스 주소(10.10.8.55)이면 소켓의 목적지 주소를 바로 백엔드 주소(10.0.0.31)로 설정한다. 이후 앱에서 해당 소켓을 통해 보내는 모든 패킷의 목적지 주소는 이미 백엔드 주소(10.0.0.31)로 설정되어 있기 때문에 중간에 DNAT 변환 및 역변환 과정이 필요없어진다.\n실제로 성능이 얼마나 개선되는지 알아보기 위해 간단한 실험을 하였다. 실험은 AB(Apache HTTP server Benchmarking tool)를 이용하였고, 결과는 아래와 같이 소켓 기반 로드밸런싱이 약 10% 정도 좋은 성능을 보여주고 있다.\ntargetrequests per second\nnetwork-based loadbalancing7263\nsocket-based loadbalancing8164\n\n여기까지 Cilium 에서 제공하는 두 가지 로드밸런싱 기법에 대해 살펴보았다.\n","description":"","id":"https://haruband.github.io/k8s-cni-loadbalancing/","title":"[K8S/Cilium] Socket-Based LoadBalancing 기법"},"https://haruband.github.io/k8s-cni-nodeport/":{"body":"외부에서 쿠버네티스 서비스에 접근하는 대표적인 방법 중의 하나는 NodePort 서비스를 이용하는 것이다. NodePort 서비스를 생성하면 30000~32767 사이의 임의의 값이 포트 번호로 할당되고, 선택된 파드가 어디에있든 상관없이 모든 노드에서 해당 포트 번호로 접근이 가능해진다.\n설명을 위해 아래와 같이 리소스를 준비해두었다.\n\n웹서버 역할을 하는 파드(nginx)는 Node1 에 위치하고, Node0 에서 Cilium 의 서비스 목록을 출력해보면, 위처럼 ClusterIP 프론트엔드와 NodePort 프론트엔드가 하나씩 보인다. (Node1 에서 Cilium 의 서비스 목록을 출력해봐도 동일하게 30645 포트를 사용하는 NodePort 프론트엔드가 보일 것이다.)\n그럼 이제 Client-To-NodePort 통신이 이루어지는 과정을 살펴보자. 클라이언트가 파드(nginx)가 위치한 노드(Node1)로 바로 접속하는 경우는 간단하기 때문에, 파드(nginx)가 위치한 노드와 다른 노드(Node0)로 접속하는 경우에 대해서 살펴보도록 하자.\n\n기본 동작 방식은 SNAT 기법을 이용하는 것이다. 즉, 출발지 주소(172.26.50.180:10000)를 클라이언트가 접속한 Node0 의 주소(172.26.50.101:31210)로 변환한 후, 해당 패킷을 Node1 로 전달한다. 이때 출발지 주소(172.26.50.101:31210)와 목적지 주소(10.0.1.72:80)를 매핑테이블에 저장해놓고, 출발지 주소(10.0.1.72:80)와 목적지 주소(172.26.50.101:31210)를 가지는 응답 패킷이 들어오면 앞에서 매핑테이블에 저장해놓은 정보를 이용해서 목적지 주소를 클라이언트 주소(172.26.50.180:10000)로 변환한 다음, 해당 패킷을 클라이언트로 전달한다.\n그럼 이제 패킷이 전달되는 과정을 좀 더 상세히 살펴보도록 하자.\n클라이언트에서 Node0 으로 전송된 패킷은 물리 네트워크 장치의 ingress BPF 프로그램(cilium/bpf/bpf_host.c#from-netdev)에 의해 먼저 목적지 주소(172.26.50.101:30645)를 백엔드 주소(10.0.1.72:80)로 변환한 다음, conntrack 맵에 변환정보를 저장해놓는다. 그리고 백엔드 주소가 동일한 노드에 있으면 패킷을 바로 전달하고, 다른 노드이면 출발지 주소(172.26.50.180:10000)를 Node0 의 주소(172.26.50.101:31210)로 변환한 다음, cilium_snat_v4_external 맵에 변환정보를 저장해놓는다. 결과적으로 위 그림의 2번과 같은 형태로 패킷이 전달된다.\nNode1 의 Pod3 에서 해당 패킷을 처리한 다음, 위 그림의 3번과 같은 형태로 응답 패킷을 전송하는데, 이를 수신한 Node0 은 물리 네트워크 장치의 ingress BPF 프로그램(cilium/bpf/bpf_host.c#from-netdev)에서 우선 cilium_snat_v4_external 맵에 저장된 정보를 이용하여 목적지 주소(172.26.50.101:31210)를 클라이언트 주소(172.26.50.180:10000)으로 변환하고, 이어서 conntrack 맵에 저장된 정보를 이용하여 출발지 주소(10.0.1.72:80)를 Node0 의 주소(172.26.50.101:30645)로 변환한다. 이러한 과정을 거쳐 클라이언트는 패킷을 보낸 주소 그대로 패킷을 받게 되는 것이다.\n여기까지 Cilium 에서 Client-To-NodePort 통신이 이루어지는 과정을 살펴보았다.\n","description":"","id":"https://haruband.github.io/k8s-cni-nodeport/","title":"[K8S/Cilium] NodePort 서비스"},"https://haruband.github.io/k8s-cni-redirect/":{"body":"Cilium 에서 VETH 를 기반으로 Pod-To-Pod 통신이 이루어지는 과정은 아래 그림의 왼쪽과 같다. Pod1 의 eth0 으로 패킷을 전달하면 veth1 을 통해 호스트 네트워크 스택으로 패킷이 전달된다. 여기에서 목적지 주소를 이용하여 몇 단계의 처리를 거친 다음 veth0 을 통해 Pod0 의 eth0 으로 패킷이 전달되는데, Cilium 은 이러한 불필요한 과정을 줄이기 위해 bpf_redirect_peer() 라는 새로운 함수를 리눅스 커널에 추가하였다. 해당 함수를 이용하면 Pod-To-Pod 통신은 오른쪽 그림과 같이 훨씬 단순해진다.\n\nbpf_redirect_peer() 함수의 역할은 단순하다. 이를 이용하여 특정 네트워크 장치로 패킷을 전달하면, 패킷이 해당 장치로 전달되는 것이 아니고 해당 장치의 연결장치(Peer)로 전달되는 것이다. (파드의 eth0 과 veth 는 한쌍의 VETH 이고, veth 의 연결장치는 파드의 eth0 이다.)\nPod3 의 eth0 과 연결된 veth1 의 ingress BPF 프로그램에서 bpf_redirect_peer() 함수를 이용하여 Pod2 로 패킷을 전달하면, 호스트 네트워크 스택과 veth0 을 거치지 않고 바로 Pod2 의 eth0 으로 패킷이 전달된다.\n이와 유사하게 VETH 를 기반으로 Pod-To-Node 통신이 이루어지는 과정은 아래 그림의 왼쪽과 같다. Pod1 의 eth0 으로 패킷을 전달하면 veth1 과 호스트 네트워크 스택을 거쳐 호스트의 eth0 으로 패킷이 전달된다. Cilium 은 이러한 불필요한 과정을 줄이기 위해 bpf_redirect_neigh() 라는 새로운 함수를 리눅스 커널에 추가하였고, 앞의 경우처럼 이를 이용하면 Pod-To-Node 통신은 훨씬 단순해진다.\n\nbpf_redirect_neigh() 함수의 역할 또한 단순하다. 이를 이용하면, 몇 단계에 걸친 네트워크 스택을 통과하지 않고, 바로 라우팅 테이블을 이용하여 다음 목적지(hop)를 정하고, 필요시 ARP 테이블을 갱신한 다음 해당 패킷을 장치로 전달한다.\n여기까지 bpf_redirect_peer()/bpf_redirect_neigh() 함수를 이용하여 Pod-To-Pod/Pod-To-Node 통신이 이루어지는 과정을 살펴보았다.\n","description":"","id":"https://haruband.github.io/k8s-cni-redirect/","title":"[K8S/Cilium] bpf_redirect_peer()/bpf_redirect_neigh()"},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"body":"쿠버네티스의 CNI 에서 성능에 가장 큰 영향을 미치는 것은 다음 두 가지이다.\n\neBPF 를 사용하느냐, 아니면 IPTables (IPVS) 를 사용하느냐?\nDirect Routing 을 사용하느냐, 아니면 Tunneling 을 사용하느냐?\n\nCilium 과 가장 대표적인 CNI 인 Calico 를 이용하여 어느 정도의 성능 차이가 나는지 살펴보자. Cilium 은 기본적으로 eBPF 를 사용하고 있고, Calico 는 최근에 eBPF 지원 기능을 추가하였다.\n첫 번째 실험은 아파치 벤치마크(AB)를 이용하여 진행하였고, 로컬 파드는 NGINX 파드와 동일한 노드에서 벤치마크를 실행한 경우이고, 리모트 파드는 다른 노드에서 벤치마크를 실행한 경우이다. (실험에 소요된 시간이므로 낮을수록 좋은 결과이다.)\n\n로컬 파드는 같은 노드 안에서만 패킷을 전달하기 때문에 전체적으로 유사한 성능을 보이지만, IPTables 기반의 Calico 는 20~30% 정도 느린 성능을 보이고 있다. 리모트 파드는 eBPF + Direct Routing 을 사용하는 경우가 가장 좋은 성능을 보이고 있다. Cilium 의 경우 VXLAN 기반 터널링보다 20% 정도 좋은 성능을 보이고 있고, Calico 는 IPTables + VXLAN 기반 터널링보다 22% 정도 좋은 성능을 보이고 있다. 그리고 IPTables 를 사용할 때는 룰의 개수가 많아질수록 더 나쁜 성능을 보이기 때문에 Cilium 을 사용하거나, Calico 를 사용하는 경우에도 eBPF 를 사용하는 것이 좋을 것이다. 또한, 모든 노드가 같은 서브넷에 있을때는 Direct Routing 을 사용하는 것이 유리하고, Calico 는 같은 서브넷에 있는 노드끼리는 Direct Routing 을, 다른 서브넷에 있는 노드끼리는 터널링 기법을 자동으로 적용하는 CrossSubnet 기능을 제공하고 있다.\n두 번째 실험에서는 Cilium 에서 DSR(Direct Server Return)을 적용하는 경우 어느 정도의 성능 차이가 나는지 살펴보자. 실험은 외부 클라이언트에서 NodePort 로 접근해서 HTTP 요청을 처리하는데 소요되는 시간의 P99 값을 측정하였다. (k6.js 를 이용하여 실험하였다.)\ndatapathtargetDSRhttp_req_duration (msecs)\ndirectlocalX0.554\ndirectremoteX0.818\ndirectremoteO0.650\nvxlanlocalX0.542\nvxlanremoteX1.896\nvxlanremoteO1.263\n\nNodePort 로 접근한 노드에 NGINX 파드가 있는 경우(local)는 0.55 msecs 내외의 시간이 소요된다. NodePort 로 접근한 노드와 다른 노드에 NGINX 파드가 있는 경우(remote)는 Direct Routing 은 0.818 msecs 가 소요되고, VXLAN 기반 터널링은 1.896 msecs 가 소요되지만, DSR 을 적용하는 경우 각각 25%(0.650 msecs)와 40%(1.263 msecs) 정도의 성능이 개선된다. 그리고 DSR 을 적용하면 응답 패킷을 다른 노드를 거치지 않고 외부 클라이언트로 바로 전송하기 때문에 클러스터 내부의 네트워크 트래픽을 줄이는 효과도 볼 수 있다.\n","description":"","id":"https://haruband.github.io/k8s-cni-routing-benchmark/","title":"[K8S/Cilium] 라우팅 기법 성능 평가"},"https://haruband.github.io/k8s-cni-service/":{"body":"일반적으로 쿠버네티스 환경에서는 서비스(Service)를 통해 파드와 통신한다. 이는 특정 파드에 직접 접속하는 것보다 서비스의 셀렉터를 통해 선택된 여러 파드들 중 하나와 통신하는 것이 로드밸런싱이나 고가용성을 보장하는데 더 유리하기 때문이다. 쿠버네티스에서는 몇 가지 종류의 서비스를 정의하고 있는데, 클러스터 내부에서 접근할 때는 주로 ClusterIP 서비스를 이용하고, 외부에서 접근할 때는 NodePort 나 LoadBalancer 서비스를 이용한다. 쿠버네티스는 이러한 서비스의 역할을 정의만할 뿐이고, 실제로 이를 구현하는 것은 Cilium 과 같은 CNI 의 역할이다. Cilium 에서 가장 기본적인 Pod-To-Service 통신이 이루어지는 과정에 대해 살펴보도록 하자.\n\n설명을 위해 아래와 같이 리소스를 준비해두었다.\n\n웹서버 역할을 하는 파드(nginx)를 하나 준비해두고, run=nginx 라는 셀렉터를 가지는 서비스(nginx)를 생성하면 하나의 엔드포인트가 자동으로 생성된다. (여기서는 run=nginx 라벨을 가지는 파드(nginx)가 하나 밖에 없기 때문에 엔드포인트가 하나만 보이지만, 파드(nginx)가 두 개 이상이면 두 개 이상의 엔드포인트가 목록에 보일 것이다.) 그리고 Cilium 에서는 파드와 서비스 리소스를 지켜보면서(watch) 필요한 객체를 몇 가지 BPF 해시 맵(cilium_lxc, cilium_lb4_services_v2, ...)에 아래와 같이 추가한다.\n\n여기까지 필요한 리소스는 준비되었고, 이를 통해 어떻게 Pod-To-Service 통신이 이루어지는지 살펴보자.\n기본 동작 방식은 DNAT 기법을 이용하는 것이다. 즉, 목적지 주소가 서비스 주소(10.98.36.83:80)이면 이를 백엔드 주소(10.0.1.72:80)로 변환해서 전송하고, 출발지 주소(10.0.0.31:10000)와 목적지 주소(10.0.1.72:80)를 매핑테이블에 저장해놓는다. 그리고 출발지 주소(10.0.1.72:80)가 백엔드 주소이고 목적지 주소(10.0.0.31:10000)가 기존의 출발지 주소인 패킷이 들어오면 앞에서 매핑테이블에 저장해놓은 정보를 이용해서 출발지 주소를 서비스 주소로 역변환한다. 이렇게 하면 클라이언트 입장에서는 그냥 단순히 서비스 주소와 통신한 것처럼 생각하게 된다. (기존의 iptables 에서 제공하는 DNAT, conntrack 과 기본적인 동작 방식은 같다.)\n이제 서비스 주소를 백엔드 주소로 변환하는 역할을 수행하는 BPF 프로그램에 대해 살펴보자.\n해당 역할은 LXC BPF 프로그램에서 수행할 수도 있지만, 현재 Cilium 에서는 SOCK BPF 프로그램(cilium/bpf/bpf_sock.c)을 루트 CGROUP 에 연결해서 해당 변환 과정을 처리한다. (이렇게 SOCK BPF 프로그램을 이용하면 호스트에서도 쿠버네티스 서비스에 접근 가능해진다.) 쿠버네티스에서 파드를 생성하면 하위 CGROUP 을 생성하는데, 하위 CGROUP 은 기본적으로 상위 CGROUP 의 BPF 프로그램을 상속받기 때문에 Cilium 에서 데몬을 시작할때 필요한 BPF 프로그램을 루트 CGROUP 에 등록해놓으면 모든 파드는 해당 BPF 프로그램을 상속받게 된다.\n실제 SOCK BPF 프로그램이 하는 역할을 살펴보면, connect() 와 sendto() 소켓 함수에 연결된 프로그램(connect4, sendmsg4)에서는 소켓의 목적지 주소(10.98.36.83)와 포트(80)를 백엔드 주소(10.0.1.72)와 포트(80)로 변환하고, cilium_lb4_reverse_sk 맵에 백엔드 주소와 포트를 등록해놓는다. (위의 그림에서 1-2번에 해당한다.) 그리고 recvmsg() 소켓 함수에 연결된 프로그램(recvmsg4)에서는 cilium_lb4_reverse_sk 맵을 이용해서 목적지 주소(10.0.1.72)와 포트(80)를 다시 서비스 주소(10.98.36.83)와 포트(80)로 변환하게 된다. (위의 그림에서 11-12번에 해당한다.)\n나머지 과정(3-10번)은 VXLAN 혹은 IPVLAN 을 이용한 Pod-To-Pod 통신 과정과 동일하다.\n참고로, 백엔드가 두 개 이상일 경우에는 어느 백엔드로 패킷을 전달할지를 결정해야 한다. Cilium 에서는 기본적으로 랜덤하게 백엔드를 선택하지만, Consistent Hash 기반의 Maglev 도 지원할 계획이라고 한다.\n여기까지 Cilium 에서 Pod-To-Service 통신이 이루어지는 과정을 살펴보았다.\n","description":"","id":"https://haruband.github.io/k8s-cni-service/","title":"[K8S/Cilium] ClusterIP 서비스"},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"body":"Cilium 이 최근 공개한 eBPF 기반의 서비스 메쉬에서 중요하게 언급하고 있는 것 중에 하나는 파드마다 사이드카 형태로 프록시를 추가하지 말고 노드별로 하나씩만 설치해서 사용하자는 것이다. 이는 특히 대규모의 클러스터에서 많은 사이드카 프록시로 인해 발생하는 자원 소모를 줄일 수 있을 것으로 기대되는데, 오늘은 Cilium 에서 노드별 프록시(Per-Node Proxy)가 어떤 방식으로 동작하는지 살펴보도록 하자. (일반적으로 가장 많이 사용하는 엔보이(Envoy)를 기준으로 설명하겠다.)\n원활한 설명을 위해 Cilium 이 제공하는 인그레스(Ingress) 예제를 이용하여 설명하도록 하겠다. 해당 예제는 Istio 의 BookInfo 예제를 기반으로 동작하며, 아래와 같은 간단한 인그레스 설정을 제공한다.\n\n위의 인그레스를 등록하면 Cilium 오퍼레이터는 자동으로 아래와 같은 CiliumEnvoyConfig 를 만들고, Cilium 에이전트는 CiliumEnvoyConfig 를 기반으로 엔보이에 필요한 설정을 추가한다.\n\n엔보이에 대한 자세한 설명은 본문 내용과는 어울리지 않으니 관련 자료를 참고하시고 여기서는 오늘 설명할 내용을 이해하기 위해 꼭 필요한 내용만 간단히 소개하도록 하겠다. 엔보이는 리스너(Listener)를 통해 트래픽을 전달받아서 필요한 처리를 한 다음, 클러스터(Cluster)로 트래픽을 전달한다. 위의 인그레스 예제는 리스너로 들어온 HTTP 요청의 URL 을 확인하여 /details 는 default 네임스페이스의 details 서비스(default/details 클러스터)로 전달하고, 나머지는 모두 default 네임스페이스의 productpage 서비스(default/productpage 클러스터)로 전달하라는 의미이다. 두 개의 클러스터는 EDS 타입으로 설정되어있고, Cilium 에이전트가 해당 클러스터의 엔드포인트 정보를 자동으로 업데이트한다.\n간단히 Cilium 이 제공하는 인그레스 예제를 이용하여 엔보이의 리스너가 전달받은 트래픽을 어떻게 처리하는지 살펴보았으니, 이제 어떻게 엔보이의 리스너로 트래픽을 전달하는지 살펴보도록 하자.\n기존의 사이드카 방식의 프록시는 IPTables 를 이용하여 모든 트래픽을 엔보이의 특정 리스너로 전달하는 방식을 사용하지만, Cilium 의 노드별 프록시는 특정 서비스(cilium-ingress-basic-ingress)로 들어오는 트래픽을 특정 리스너(cilium-ingress-default-basic-ingress)로 전달하는 방식을 사용하고 있다. Cilium 에이전트는 엔보이에 리스너를 등록하기 전에 임의의 포트를 할당하고, 리스너와 연결된 서비스에 해당 포트를 설정해둔다. 이후에는 해당 서비스로 들어오는 모든 트래픽은 리스너가 할당받은 포트로 전달된다.\n위의 인그레스 예제를 좀 더 살펴보면, 아래와 같이 리스너와 연결된 서비스를 확인할 수 있고, 해당 서비스로 접속하면 위에서 설정한대로 default 네임스페이스의 details 서비스와 productpage 서비스로 연결되는 것을 확인할 수 있다.\n\nCilium 은 서비스로 들어온 트래픽을 리스너로 전달하기 위해 두 가지 방식을 제공하고 있다. 첫 번째는 IPTables 를 이용하는 방식이고, 두 번째는 eBPF 를 이용하는 방식이다. 지금부터 이 두 가지 방식이 각각 어떻게 동작하는지 하나씩 살펴보도록 하자.\nIPTables 기반 트래픽 전달\nCilium 은 리스너와 연결된 서비스로 들어온 모든 패킷에 매직 코드(0x200)와 리스너의 포트를 마킹한다. 아래는 위의 인그레스 예제에서 사용 중인 엔보이의 열린파일 목록이다. 이를 통해 우리는 리스너가 할당받은 포트가 18243 번인 것과 Cilium 이 해당 서비스로 들어온 모든 패킷에 18243 을 상위 16 비트로, 0x200 을 하위 16 비트로 하는 0x43470200 을 마킹하는 것을 알 수 있다.\n\nCilium 은 다른 목적지 주소를 가지는 패킷을 엔보이로 전달하기 위해 아래와 같이 IPTables 가 제공하는 TPROXY 를 사용한다. 아래 CILIUM_PRE_mangle 체인을 보면 0x43470200 이 마킹된 패킷을 18243 포트로 전달하는 룰을 볼 수 있다.\n\n외부에서 해당 서비스에 접속해보면, 아래와 같이 엔보이에 연결이 추가되어있는걸 확인할 수 있다.\n\neBPF 기반 트래픽 전달\nCilium 은 리스너와 연결된 서비스로 들어온 모든 패킷을 리스너가 할당받은 포트로 바로 전달한다. BPF 프로그램에서 해당 포트와 연결된 소켓을 패킷에 바로 연결해버리기 때문에 굉장히 간단하다.\n외부에서 해당 서비스에 접속해보면, IPTables 의 TPROXY 없이도 목적지 주소가 다른 패킷이 엔보이로 잘 전달되는 것을 볼 수 있다.\n\n","description":"","id":"https://haruband.github.io/k8s-cni-servicemesh-proxy/","title":"[K8S/Cilium] eBPF 기반 서비스 메쉬 분석 (Per-Node Proxy)"},"https://haruband.github.io/k8s-cni-vxlan/":{"body":"Cilium 은 VXLAN 에 기반한 Tunneling Datapath 기법을 제공하고 있다. VXLAN 은 리눅스 커널이 제공하는 기능이므로 VXLAN 에 대한 자세한 설명은 생략하고, Cilium 의 동작 과정을 설명하면서 필요한 부분에 대해서만 간단히 부연설명하겠다. (본 블로그에서는 VXLAN 에 대한 내용에 집중하기 위해 서비스(Service)에 대한 처리 과정은 생략하겠다.)\n아래 그림은 Cilium 에서 VXLAN 을 사용할 경우 Pod-To-Pod 통신이 이루어지는 과정이다. Node0 의 Pod0 에서 Node1 의 Pod3 으로 패킷을 보내는 과정을 살펴보도록 하자. (파드가 서로 다른 노드에 존재하는 경우에 대해서만 설명하겠다.)\n\n우선 그림에 나오는 몇 가지 네트워크 장치에 대해 설명하도록 하겠다.\n첫 번째로, Cilium 에서는 새로운 파드를 생성할 때마다 VETH 한쌍을 생성한다. VETH 는 두 개의 가상 네트워크 장치를 생성하여 서로 연결해주는 기능을 제공한다. 위의 그림에서 보면 Pod0 의 eth0 과 Node0 의 veth0 은 연결된 한쌍의 VETH 이고, 이는 eth0 으로 패킷을 전달하면 veth0 을 통해 패킷이 나가게 되고, 반대로 veth0 을 통해 패킷이 들어오면 eth0 으로 패킷을 수신할 수 있다는 뜻이다.\n두 번째로, Cilium 에서는 실제 VXLAN 통신을 담당할 가상 네트워크 장치를 생성한다. 이는 cilium_vxlan 이라는 이름을 사용하고, 노드별로 하나씩 생성된다. veth0 에서 필요한 정보와 함께 L2 패킷을 cilium_vxlan 장치로 전달하면, cilium_vxlan 은 해당 L2 패킷에 VXLAN 헤더와 해당 패킷을 물리적인 네트워크 환경을 통해 전달하기 위해 필요한 L2/L3/UDP 헤더를 추가하여 물리 네트워크 장치(Node0 의 eth0)로 내보내게 된다. (VXLAN 은 UDP 프로토콜을 이용하여 패킷을 전달한다.) 아래는 VXLAN 을 통해 외부로 나가는 실제 패킷의 구조이다.\n\n위의 그림을 기준으로 실제 패킷에 들어가는 값을 정리해보면, 내부 IP 헤더의 출발지 주소는 10.0.0.31, 목적지 주소는 10.0.1.72 이고, 외부 IP 헤더의 출발지 주소는 172.26.50.101, 목적지 주소는 172.26.50.102 이다. 그리고 외부 UDP 헤더의 목적지 포트는 VXLAN 이 기본적으로 사용하는 8472 이다.\n마지막으로, Node0 과 Node1 에 있는 eth0 는 물리 네트워크 장치를 의미한다.\n그럼 이제 패킷이 전달되는 과정을 좀 더 상세히 살펴보도록 하자.\nNode0 의 Pod0 에서 생성된 패킷은 eth0 을 통해 veth0 으로 전달된다. veth0 의 ingress BPF 프로그램(cilium/bpf/bpf_lxc.c#from-container)의 역할은 목적지 주소가 동일한 노드이면 해당 목적지(Pod1)의 veth1 로 패킷을 전달(redirect)하고, 다른 노드이면 cilium_tunnel_map 맵에 목적지(Pod3)의 네트워크 주소(10.0.1.0)를 해시 키값으로 사용해서 목적지 노드의 주소(172.26.50.102)를 가져온 뒤, 목적지 노드의 주소와 함께 해당 패킷을 cilium_vxlan 으로 전달(redirect)하는 것이다. (cilium 을 통해 실제 터널 목록(cilium_tunnel_map)을 출력한 결과는 아래와 같다. 터널 정보는 새로운 노드가 추가될때 해당 노드의 PodCIDR 과 주소를 이용해서 생성된다.) cilium_vxlan 에서는 앞에서 설명한 것처럼 전달받은 패킷에 VXLAN 헤더를 추가하여 물리 네트워크 장치(eth0)로 패킷을 전달(redirect)한다.\n\nNode1 의 물리 네트워크 장치(eth0)로 수신된 UDP 패킷은 cilium_vxlan 에서 VXLAN 관련 간단한 처리를 한 다음 cilium_vxlan 의 ingress BPF 프로그램(cilium/bpf/bpf_overlay.c#from-overlay)에서 처리된다. (VXLAN 드라이버에서 cilium_vxlan 장치를 생성할때 8472 UDP 포트로 들어오는 모든 패킷을 처리할 수 있는 콜백 함수를 등록해놓는다.) 여기서는 목적지 주소가 해당 노드에 있으므로 바로 해당 목적지(Pod3)의 veth1 로 패킷을 전달(redirect)해서 veth1 의 egress BPF 프로그램에서 처리해야 하지만, 성능을 높이기 위해 cilium_call_policy 맵에 목적지(Pod3)의 엔드포인트 아이디를 인덱스로 사용해서 저장된 프로그램(cilium/bpf/bpf_lxc.c#handle_policy)을 tailcall 로 직접 호출한다. 해당 프로그램에서는 필요한 처리를 한 뒤, 목적지(Pod3)의 veth1 로 패킷을 전달(redirect)하고, 마지막으로 해당 패킷은 Pod3 의 eth0 으로 전달된다.\n여기까지 VXLAN 을 통해 Pod-To-Pod 통신이 이루어지는 과정을 살펴보았다.\n","description":"","id":"https://haruband.github.io/k8s-cni-vxlan/","title":"[K8S/Cilium] VXLAN 기반 Tunneling Datapath 기법"},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"body":"오늘은 Istio 에서 공개한 AmbientMesh 와 Cilium 을 함께 사용할 수 없는 문제에 대해 소개하고자 한다. Cilium 뿐 아니라 다양한 CNI 와 유사한 문제가 있는 것으로 알려져 있기 때문에, AmbientMesh 를 사용하길 원한다면 지금은 Calico(+IPTables)를 사용하는 것이 좋을 것이다.\nCNI 로 Cilium 을 사용하는 경우, AmbientMesh 를 설치하면 정상적으로 동작하지 않는다. 크게 두 가지 이유가 있으니 하나씩 살펴보도록 하자.\n첫 번째는 새로운 파드의 네트워크 환경을 구축해주는 CNI 플러그인 설정 파일 관련된 문제이다. 쿠버네티스 환경에서 새로운 파드가 추가되면 컨테이너 런타임(cri-o)은 등록된 CNI 플러그인(/etc/cni/net.d)을 이용하여 새로운 파드를 위한 네트워크 환경을 구축한다. 예를 들어, Cilium 을 사용하는 경우, 아래와 같은 CNI 플러그인 설정을 볼 수 있다.\n\n위의 CNI 플러그인 설정을 가진 환경에서 새로운 파드가 추가되면 컨테이너 런타임은 CNI 플러그인 실행 파일 디렉토리(/opt/cni/bin)에서 타입 이름(cilium-cni)과 동일한 이름을 가진 파일(/opt/cni/bin/cilium-cni)을 실행(CmdAdd)한다. 이런 방식으로 실행된 CNI 플러그인 실행 파일(cilium-cni)은 새롭게 추가된 파드를 위한 네트워크 장치를 만들고 eBPF 프로그램을 등록하는 등의 일을 수행한다.\nAmbientMesh 도 기존의 CNI 와 유사한 방식으로 동작하는데, CNI 플러그인(istio-cni)을 등록하고, 새로운 파드가 추가되면 CNI 플러그인 실행 파일(/opt/cni/bin/istio-cni)이 실행되어 필요한 eBPF 프로그램을 등록하는 등의 일을 수행한다.\n여기서 문제는 AmbientMesh 가 CNI 플러그인 설정 파일 디렉토리(/etc/cni/net.d)를 모니터링하면서 파일이 변경될 때마다 자신이 필요한 설정을 추가하는데, Cilium 도 CNI 플러그인 설정 파일 디렉토리를 모니터링하면서 파일이 변경될 때마다 불필요한 설정을 제거한다는 것이다.\n그래서 CNI 플러그인 설정 파일을 담당하는 파드(cilium, istio-cni-node)의 로그를 살펴보면, 아래처럼 반복적으로 설정 파일을 서로 수정하는 것을 볼 수 있다.\n\nAmbientMesh 가 원하는 CNI 플러그인 설정은 아래와 같지만, Cilium 에서 설정 파일을 지속적으로 변경하고 있는 것이다. 이 문제는 다양한 방법으로 해결할 수 있겠지만, 개인적인 생각으로는 CNI 플러그인 목록을 하나의 파일에서 관리하지 않고, 여러 파일로 분리해서 각자 관리하는 것이 깔끔해 보인다.\n\n두 번째는 서비스 주소를 파드 주소로 변환해주는 로드밸런싱과 관련된 문제이다. Cilium 에서는 일반적으로 파드의 호스트 네트워크 장치(veth0)의 ingress BPF 프로그램(B)에서 로드밸런싱을 수행하고, 소켓 기반 로드밸런싱을 사용하는 경우에는 파드가 Connect 시스템콜을 호출(A)할 때 서비스 주소를 파드 주소로 미리 변환한다. 이렇게 되면 Ztunnel 과 프록시(Waypoint)가 전달받는 패킷의 목적지 주소는 서비스 주소가 아닌 파드 주소이기 때문에, 대부분의 정책이 서비스 주소를 기반으로 동작하는 Istio 는 올바르게 정책을 수행할 수 없게 된다. 그래서 AmbientMesh 를 사용하는 경우, Cilium 에서 로드밸런싱을 막거나 별도의 방법으로 원래의 목적지(서비스) 주소를 알아낼 수 있는 방법이 필요할 것으로 보인다.\n\n지금까지 AmbientMesh 와 Cilium 을 함께 사용할 수 없는 문제에 대해 분석하였다. 두 가지 문제 모두 해결이 어렵진 않지만, 고려해야할 사항들이 많기 때문에 많은 논의가 필요해보인다.\n","description":"","id":"https://haruband.github.io/k8s-istio-ambientmesh-cilium/","title":"[K8S/Istio] AmbientMesh Cilium 문제 분석"},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"body":"오늘은 Istio 에서 공개한 AmbientMesh 의 동작 과정을 분석해보도록 하겠다. 성능이나 확장성 면에서 우수한 eBPF 모드를 기준으로 설명할 계획이며, CNI 는 Calico(+IPTables)를 사용하였다.\n아래 그림은 출발지 파드(jupyterlab)에서 목적지 파드(nginx)로 패킷이 전달되는 과정을 보여주고 있다. (출발지 파드에서는 목적지 서비스(nginx)의 주소(172.16.52.69)로 접속하였다.) 목적지 파드는 프록시(Waypoint)가 설치된 네임스페이스(default)에 속해있기 때문에 패킷은 해당 프록시를 통해서 전달된다. 설명은 패킷이 전달되는 순서대로(그림에 표시된 1~8번까지의 숫자) 진행하도록 하겠다.\n\n1번은 출발지 파드에서 패킷이 송신되는 단계이다. 패킷의 출발지 물리주소(4e:c8:60:12:7b:5b)는 출발지 파드(juypterlab)의 네트워크 장치(eth0)의 주소이고, 목적지 물리주소(ee:ee:ee:ee:ee:ee)는 출발지 파드의 호스트 네트워크 장치(veth0)의 주소이다. 그리고 패킷의 출발지/목적지 주소는 각각 출발지 파드(10.69.11.36)와 목적지 서비스(172.16.52.69)의 주소이다.\n\n출발지 파드의 네트워크 장치(eth0)를 통해 송신된 패킷은 VETH 로 연결된 호스트 네트워크 장치(veth0)로 전달되고, 호스트 네트워크 장치(veth0)의 ingress BPF 프로그램(A)에서는 패킷의 목적지 물리주소를 터널링 파드(ztunnel0)의 네트워크 장치(eth1)의 물리주소(3e:53:50:ac:00:d4)로 수정한 다음, 강제로 터널링 파드의 호스트 네트워크 장치(veth1)로 전달(redirect)한다. 그리고 호스트 네트워크 장치(veth1)로 전달된 패킷은 VETH 로 연결된 네트워크 장치(eth1)로 전달된다.\n2번은 터널링 파드에서 패킷이 수신되는 단계이다. 수신된 패킷은 네트워크 장치(eth1)의 ingress BPF 프로그램(B)에서 강제로 Ztunnel 이 아웃바운드 포트(15001)로 대기(listen)하고 있는 소켓으로 전달된다. 이 때 생성(accept)되는 소켓의 로컬 주소는 전달받은 패킷의 목적지 주소인 목적지 서비스(172.16.52.69:80)의 주소이고, conntrack 맵에도 목적지 주소는 목적지 서비스(172.16.52.69:80)의 주소로 등록되어 있다.\n\n3번은 터널링 파드에서 패킷이 송신되는 단계이다. 목적지 서비스가 속해있는 네임스페이스가 프록시(Waypoint)를 사용하기 때문에 전달받은 패킷은 프록시(10.69.149.2)로 전달된다. 이때 패킷의 출발지 주소는 터널링 파드의 주소가 아닌 전달받은 패킷(2)의 출발지 주소인 출발지 파드의 주소(10.69.11.36)를 사용한다. 그렇다면 프록시가 보내는 패킷(응답)의 목적지 주소도 출발지 파드의 주소이겠지만, 출발지 파드가 받는 모든 패킷은 터널링 파드가 가로채기 때문에 문제없이 동작한다. 그리고 원래의 목적지 주소(172.16.52.69:80)는 HTTP/2 Connect 기반의 HBONE 프로토콜을 이용하여 Ztunnel 과 프록시가 연결되기 때문에 URI 로 전달된다.\n\n4번은 프록시 파드에서 패킷이 수신되는 단계이다. 프록시는 패킷의 출발지 주소(10.69.11.36)와 URI 로 전달받은 원래의 목적지 주소(172.16.52.69:80)를 이용하여 필요한 정책을 수행한 다음 목적지 파드(nginx)를 결정한다.\n\n5번은 프록시 파드에서 패킷이 송신되는 단계이다. 전달받은 패킷을 목적지 파드(nginx)의 주소(10.88.135.163)로 전달하지만, 목적지 파드의 노드(node2)에 있는 터널링 파드가 패킷을 가로채기 때문에 패킷의 목적지 포트는 Ztunnel 의 인바운드 포트(15008)를 사용한다. 그리고 3번과 마찬가지로 Ztunnel 과 프록시(Waypoint)는 HBONE 프로토콜로 연결되기 때문에 원래의 목적지 주소(10.88.135.163:80)는 URI 로 전달된다.\n\n목적지 파드의 호스트 네트워크 장치(veth4)로 수신된 패킷은 egress BPF 프로그램(C)에서 패킷의 목적지 물리주소를 터널링 파드(ztunnel2)의 네트워크 장치(eth5)의 물리주소(ce:7f:ba:06:21:08)로 수정한 다음, 강제로 터널링 파드의 호스트 네트워크 장치(veth5)로 전달한다. 그리고 호스트 네트워크 장치(veth5)로 전달된 패킷은 VETH 로 연결된 네트워크 장치(eth5)로 전달된다.\n6번은 터널링 파드에서 패킷이 수신되는 단계이다. 수신된 패킷은 네트워크 장치(eth5)의 ingress BPF 프로그램(D)에서 강제로 Ztunnel 이 인바운드 포트(15008)로 대기(listen)하고 있는 소켓으로 전달된다.\n\n7번은 터널링 파드에서 패킷이 송신되는 단계이다. 프록시에서 URI 로 전달받은 원래의 목적지 주소(10.88.135.163:80)로 패킷을 전달한다. 3번과 마찬가지로, 패킷의 출발지 주소는 터널링 파드의 주소가 아닌 전달받은 패킷의 출발지 주소(10.69.149.2)를 그대로 사용한다.\n\n터널링 파드의 호스트 네트워크 장치(veth5)로 수신된 패킷은 ingress BPF 프로그램(E)에서 패킷의 목적지 물리주소를 목적지 파드(nginx)의 네트워크 장치(eth4)의 물리주소(ba:02:f4:c8:98:77)로 수정한 다음, 강제로 목적지 파드의 호스트 네트워크 장치(veth4)로 전달한다. 여기서 중요한 점은 호스트 네트워크 장치(veth4)로 수신된 패킷이 다시 터널링 파드로 전달되는 것을 막기 위해 패킷에 정해진 표시(BYPASS)를 해야한다는 것이다. 호스트 네트워크 장치(veth4)의 egress BPF 프로그램(C)이 정해진 표시(BYPASS)가 있는 패킷은 터널링 파드로 전달하지 않기 때문이다. 그래서 목적지 파드의 호스트 네트워크 장치(veth4)로 수신된 패킷은 터널링 파드로 전달되지 않고 VETH 로 연결된 네트워크 장치(eth4)로 전달된다.\n8번은 목적지 파드에서 패킷이 수신되는 단계이다. 아직은 프록시(Waypoint)가 투명하게 동작하지 않기 때문에 원래의 출발지 주소가 아닌 프록시의 주소로 전달된다.\n\n지금까지 AmbientMesh 의 동작 과정에 대해 살펴보았고, 아직 초기 개발 단계이기 때문에 앞으로 많은 부분이 변경되거나 개선될 수 있다. eBPF 를 이용하여 패킷의 흐름을 제어하는 것들(Cilium, ...)은 대부분 유사한 방식으로 동작하기 때문에, 위의 내용을 정확히 이해하면 CNI 의 동작 과정을 이해하는데도 많은 도움이 될 것이다.\n","description":"","id":"https://haruband.github.io/k8s-istio-ambientmesh-flow/","title":"[K8S/Istio] AmbientMesh 동작 과정 분석"},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"body":"오늘은 Istio 에서 공개한 AmbientMesh 를 처음 설치할 때 겪었던 문제에 대해 소개하고자 한다. 주로 사용하는 Cilium 은 아직 지원되지 않기 때문에 Calico(+IPTables)를 CNI 로 사용하였다.\n간단히 AmbientMesh 를 설치했는데, Ztunnel 이 정상적인 동작을 하지 않았고, 아래와 같은 로그가 반복적으로 출력되고 있었다.\n\n정확한 원인을 파악하기 위해, Ztunnel 의 네트워크 네임스페이스(nsenter)에서 송수신 패킷을 확인(tcpdump)해보니, 아래와 같이 DNS 요청은 나가는데 응답이 오지 않는 상황이었다. 그래서 호스트 네트워크 네임스페이스에서 확인해보니 DNS 요청이 외부로 나가지 않고 있었다. 이런 경우에는 요청 패킷이 호스트에서 드롭되고 있을 가능성이 높고, 주요 원인으로 생각해볼 수 있는 것은 바로 RPFilter 이다. 이유는 Ztunnel 이 투명하게 동작하기 위해 패킷을 전달할 때 출발지 주소로 원래의 출발지 주소를 사용해서 RPFilter 에 의해 문제가 발생할 가능성이 높기 때문이다.\nRPFilter 는 해커들이 DDoS 공격을 할 때 주로 사용하는 IP 스푸핑(Spoofing)을 막기 위해 사용되는 기술이다. IP 스푸핑은 패킷의 출발지 주소를 임의로 조작하여 원하는 결과를 얻어내는 기술이고, RPFilter 는 응답 패킷을 동일한 네트워크 장치를 이용하여 출발지 주소로 전달할 수 있는지를 확인해서 IP 스푸핑을 방지하는 기술이다.\n\n우선, 리눅스의 네트워크 스택에 포함되어 있는 RPFilter 기능을 사용하고 있는지를 확인해보았다. 아래와 같이 모든 파드의 호스트 네트워크 장치는 RPFilter 기능을 사용하지 않았고, 이는 Calico 에서 해당 기능 대신 IPTables 가 제공하는 RPFilter 기능을 사용하기 때문이었다.\n\n아래는 Calico 가 사용하고 있는 RPFilter 관련된 IPTables 체인 목록이다. 보시는 것처럼 cali-PREROUTING 체인의 4번 룰에서 RPFilter 를 이용하여 패킷을 드롭하는 걸 볼 수 있다.\n\n그렇다면 Calico 에서도 AmbientMesh 를 사용할 수 없는 것일까? 그건 아니었고, 아래를 보면 Ztunnel 파드에 이를 해결하기 위한 설정(allowedSourcePrefixes)이 들어있는 것을 볼 수 있다. 해당 설정은 RPFilter 를 우회하기 위한 설정으로, 등록된 주소 대역은 출발지 주소로 사용할 수 있다는 의미이다. 즉, 아래와 같이 설정되었다면 Ztunnel 파드는 패킷의 출발지 주소로 10.0.0.0/8 의 주소 대역을 사용할 수 있다는 것이다.\n\n그런데, Ztunnel 파드에 필요한 설정이 들어있음에도 불구하고, 왜 정상적으로 동작하지 않은 것일까? 이유는 해당 설정을 Calico 에서 사용하지 않고 있었기 때문이었다. 해당 기능을 활성화하기 위해서는 Calico 파드(calico-node)에 아래의 환경 변수를 추가해야 한다.\n\nCalico 에 해당 기능을 추가한 다음, 다시 IPTables 체인 목록을 확인해보면 4번 룰(DROP)보다 앞에 있는 3번 룰(cali-rpf-skip)의 체인에 새로운 룰이 추가된 것을 볼 수 있다. cali-rpf-skip 체인에 추가된 1번 룰은 위에서 설정한 대로 출발지 주소가 10.0.0.0/8 이면 패킷을 허용(ACCEPT)한다는 의미이다.\n\n지금까지 AmbientMesh 를 처음 설치하면서 겪었던 문제에 대해 분석하였다. AmbientMesh 뿐 아니라 대부분의 CNI 는 패킷을 조작하여 원하는 기능을 수행하는 경우가 많기 때문에 RPFilter 에 대해서는 충분히 이해하고 있을 필요가 있다.\n","description":"","id":"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/","title":"[K8S/Istio] AmbientMesh RPFilter 문제 분석"},"https://haruband.github.io/k8s-istio-ambientmesh/":{"body":"Istio 는 가장 유명한 서비스 메시(Service Mesh) 솔루션이고, 쿠버네티스를 사용하는 대부분의 회사들이 Istio 를 사용하고 있다. 하지만, 예전부터 Istio 가 사용하던 프록시(Envoy) 기반의 사이드카(Sidecar) 방식은 다양한 문제와 한계를 드러내고 있다. 오늘은 이를 해결하기 위해 최근 공개된 AmbientMesh 에 대해 소개하고자 한다. (해당 기능은 아직 한창 개발 중이기 때문에 제품에 적용할 수 있는 단계는 아니다.)\n우선, Istio 가 AmbientMesh 를 이용하여 해결하고자 하는 문제부터 간단히 살펴보자.\n첫 번째는, 굉장히 다양한 기능을 제공하는 프록시를 모든 파드에 사이드카 형태로 삽입하는 방식으로 동작하기 때문에 정확한 자원 사용량을 예측하기 힘들고 필요 이상으로 자원 사용량이 증가한다는 것이다.\n두 번째는, 트래픽 관련 정책은 출발지(Source) 파드에 있는 프록시에서 처리하고 대부분의 보안 관련 정책은 목적지(Destination) 파드에 있는 프록시에서 처리한다는 것이다. 이로 인해 발생하는 구체적인 문제는 다음과 같다.\n\n확장성 - 모든 파드의 프록시가 모든 파드에 대한 정책을 알고 있어야 하기 때문에, 특정 파드에 대한 정책이 변경되면 모든 파드의 프록시가 갱신되어야 한다.\n보안성 - 모든 파드의 프록시가 모든 파드에 대한 정책을 알고 있기 때문에 보안적으로 안전하다고 볼 수 없다.\n디버깅 - 어떤 정책은 출발지 파드의 프록시에서 처리하고, 어떤 정책은 목적지 파드의 프록시에서 처리하기 때문에 문제가 발생했을 때 파악하기 쉽지 않다.\n\n이러한 문제를 해결하기 위해 Istio 가 개발 중인 AmbientMesh 는 모든 파드에 프록시를 삽입하는 방식이 아닌, 네임스페이스(Namespace) 혹은 서비스 어카운트(ServiceAccount) 별로 하나의 프록시(Waypoint)를 설치하는 방식을 사용한다. 그리고 안전한 오버레이(Overlay) 네트워크를 제공하는 Ztunnel 을 노드 별로 하나씩 설치해서 L4 수준의 정책은 Ztunnel 에서 처리하고 L7 수준의 정책만 프록시에서 처리하는 방식도 지원한다. (Ztunnel 은 Rust 로 새로 개발되고 있기 때문에 Envoy 보다 빠르고 가볍다.)\nAmbientMesh 를 자세히 소개하기 전에 간단히 기존의 사이드카 방식(IPTables 기반)이 어떻게 동작하는지 살펴보자. 아래 그림은 서비스 메시를 사용 중인 두 개의 파드가 통신하는 과정을 보여주고 있다.\n\n앞에서 설명했던 것처럼 서비스 메시를 사용 중인 모든 파드에는 프록시(Envoy)가 삽입되어 있고, 모든 송수신 패킷은 넷필터(IPTables)에 의해 프록시로 전달되어 처리된다. 예를 들어, 카나리(Canary) 배포를 한다면 출발지 파드(Pod0)의 프록시에서 목적지 파드가 선택되고, 접근 제어 정책을 사용한다면 목적지 파드(Pod1)의 프록시에서 해당 정책이 수행된다.\n이제, AmbientMesh 가 어떻게 동작하는지 살펴보자. AmbientMesh 도 송수신 패킷을 가로채기 위해 IPTables 과 eBPF 를 지원하지만, 성능이나 확장성 면에서 우수한 eBPF 를 위주로 살펴보도록 하겠다. 아직 초기 개발 단계이기 때문에 Cilium 은 지원하지 않고, AmbientMesh 에서 eBPF 를 사용하는 경우 CNI 에서는 eBPF 를 사용할 수 없기 때문에 Calico(+IPTables)를 CNI 로 사용하였다.\n\n위의 그림은 0번 파드에서 Ztunnel 과 프록시(Waypoint)를 거쳐서 1번 파드로 패킷이 전달되는 과정을 보여주고 있다. 0번 파드에서 송신된 패킷은 호스트(Ingress)에서 같은 노드에 있는 Ztunnel 로 전달되고, 목적지 파드가 속해있는 네임스페이스(dev)에 프록시(Waypoint)가 있는 경우에는 프록시로 패킷을 전달(HBONE)한다. (HBONE 은 HTTP/2 Connect 를 이용하여 터널링을 구현한 프로토콜이다.) 프록시는 필요한 정책(트래픽/보안 관련)을 수행하고 목적지 파드(1번)가 정해지면 다시 패킷을 전달한다. 그리고 1번 파드로 전달된 패킷은 호스트(Egress)에서 같은 노드에 있는 Ztunnel 로 전달(HBONE)되고, 마지막으로 Ztunnel 에서 1번 파드로 패킷을 전달하면 기나긴 여정이 마무리된다.\n프록시가 별도의 파드로 분리되어 있기 때문에 오히려 노드간 통신이 한번 더 늘어나긴 했지만, 프록시가 분리된 파드로 동작하기 때문에 필요한 만큼의 자원을 할당할 수 있어서 관리는 용이해졌다. 그리고 프록시는 자신이 관리하는 네임스페이스와 관련된 정책만을 처리하기 때문에 불필요한 정책은 전달받을 필요도 없어졌다. (현재는 프록시가 같은 네임스페이스에 있는 파드를 목적지로 하는 정책만을 처리하지만, 이외의 다양한 정책을 처리하기 위한 개발/논의가 진행되고 있다.)\n위의 그림은 L7 수준의 정책을 처리하기 위해 프록시를 거치는 과정이고, L7 수준의 정책이 필요없다면 해당 네임스페이스에 프록시를 설치하지 않으면 된다. 이런 경우에는 출발지 파드의 Ztunnel 에서 목적지 파드의 Ztunnel 로 패킷이 바로 전달되며, Ztunnel 에서 L4 수준의 정책은 처리할 수 있다. (현재는 정책에 따라 프록시 사용유무를 판단하진 않지만, 이를 개선하기 위한 개발/논의가 진행되고 있다.)\n지금까지 AmbientMesh 에 대해 살펴보았고, 아직 초기 개발 단계이기 때문에 앞으로 많은 부분이 변경되거나 개선될 수 있다. 특히, Ztunnel 이 어떤 역할을 할지, 다양한 정책이 어디에서 어떻게 처리될지 등등은 아직 설계 단계라고 볼 수 있다.\n","description":"","id":"https://haruband.github.io/k8s-istio-ambientmesh/","title":"[K8S/Istio] AmbientMesh 소개"},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"body":"쿠버네티스(K8S)를 지원하는 대표적인 오픈소스 로드밸런서(LoadBalancer)인 MetalLB 를 이용하여 카프카(Kafka)의 네트워크 성능을 개선한 사례를 공유하고자 한다. 우리는 StrimziOperator 를 이용하여 카프카를 배포/운영하고 있으며, 초기에는 간단히 노드포트(NodePort)를 이용하여 부트스트랩(Bootstrap)과 브로커(Broker)에 접속했기 때문에 불필요한 네트워크 홉(Hop)이 추가되는 문제가 발생하였다. 우선, 간단히 노드포트가 어떻게 동작하기에 이런 문제가 생긴 것인지 알아보도록 하자.\n\n위의 그림은 클라이언트가 노드포트를 이용하여 서비스에 접근하는 과정이다. 클라이언트는 해당 서비스의 엔드포인트(Pod3)가 어느 노드에 있는지 알 수 없기 때문에 임의의 노드(위에서는 Node0)로 접속한다. 위의 경우에는 엔드포인트가 Node1 에 있었기 때문에, Node0 에서 SNAT(SourceNAT) 를 이용하여 Node1 로 요청 메세지를 송신하고 응답 메세지를 수신한 다음 클라이언트에게 전달한다. (부트스트랩이 전달해준 브로커의 주소도 노드포트 주소였기 때문에 실제 브로커 파드가 위치한 노드의 주소가 아닐 수 있다.) 이는 클라이언트가 처음부터 엔드포인트가 있는 노드(Node1)로 바로 접속했으면 발생하지 않았을 문제이고, 이 문제를 해결하기 위해 쿠버네티스가 제공하는 기능이 로드밸런서이다.\n지금부터 MetalLB 를 이용하여 어떻게 이 문제를 해결하였는지 소개하겠다. MetalLB 는 L2 모드와 BGP 모드를 지원하기 때문에 각각 어떻게 동작하는지, 어떤 장단점이 있는지도 같이 살펴보도록 하자.\n다음은 검증에 사용된 노드의 주소(IP/MAC)이다.\n\nNode0 : 192.168.200.200 (f4:6b:8c:82:42:33)\nNode1 : 192.168.200.201 (f4:6b:8c:82:42:2b)\nNode2 : 192.168.200.202 (f4:6b:8c:82:41:f8)\n\n아래는 부트스트랩과 브로커의 서비스 목록이다. 모두 로드밸런서로 설정되어 있기 때문에 할당된 외부 주소(ExternalIP)를 확인할 수 있다. (해당 리스너의 광고(Advertised) 주소는 아래 외부 주소로 설정되어있다.)\n\n그리고 브로커의 파드 목록이다. 각각 어느 노드에 있는지 확인할 수 있다.\n\nMetalLB L2 모드 기반 로드밸런싱\nL2 모드는 MetalLB 가 데몬셋으로 설치하는 스피커(Speaker)가 외부 주소(IP)에 대한 ARP 요청에 응답하는 방식이다. 간단하게 사용할 수 있지만, 서비스의 엔드포인트가 2 개 이상의 노드에 있는 경우에는 하나의 노드만 요청을 받을 수 있는 문제가 있다. 예를 들어, Node0 과 Node1 에 엔드포인트가 동시에 존재하는 경우, MetalLB 는 임의로 리더를 선출하고, 리더로 선출된 노드의 스피커가 ARP 요청에 응답한다. 결국 해당 외부 주소로는 리더로 선출된 노드에만 접근할 수 있게 된다.\n아래는 0번 브로커에 있는 토픽/파티션에 접근하는 클라이언트의 접속 정보이다. 부트스트랩으로부터 필요한 메타데이터를 가져와서 0번 브로커의 외부 주소(192.168.200.241)로 접속하는걸 볼 수 있다.\n\n그렇다면 실제로 어떤 노드로 접속했을까? 아래는 클라이언트의 ARP 캐시 목록이다.\n\n그런데 위의 물리 주소(MAC)는 0번 브로커가 있는 Node1 의 물리 주소(f4:6b:8c:82:42:2b)가 아니고, Node0 의 물리 주소(f4:6b:8c:82:42:33)이다. 왜 이런 일이 발생했을까? 이유는 외부 트래픽 정책(ExternalTrafficPolicy)이 클러스터(Cluster)로 되어있기 때문이다. 해당 정책은 외부에서 접속했을 때 다른 노드에 있는 파드에 대한 접근을 허용하기 때문에 MetalLB 는 임의의 노드를 리더로 선출한다. 그래서 외부 트래픽 정책을 다른 노드에 있는 파드에 대한 접근을 허용하지 않는 로컬(Local)로 설정하면 아래와 같이 0번 브로커가 있는 Node1 로만 접속하게 된다.\n\n이제 Node1 로 들어온 요청 메세지를 어떻게 0번 브로커 파드로 전달하는지 살펴보자. 아래는 Node1 의 서비스 목록(Cilium)이다. 외부 주소로 들어온 요청을 0번 브로커 주소(10.0.2.233)로 전달하는 것을 확인할 수 있다. (eBPF 프로그램(Cilium)에서 DNAT(DestinationNAT) 를 이용하여 메세지를 전달한다.)\n\n참고로 Node0 의 서비스 목록(Cilium)을 살펴보면, 0번 브로커의 외부 주소에 대한 백엔드가 비어있는 것을 볼 수 있다. 이는 앞에서 외부 트래픽 정책을 로컬로 설정해서 다른 노드에 있는 파드는 백엔드 목록에서 제거되기 때문이다.\n\nMetalLB BGP 모드 기반 로드밸런싱\nBGP 모드는 MetalLB 가 데몬셋으로 설치하는 스피커가 BGP 피어(Peer)로 동작하면서 라우팅 정보를 갱신하는 방식이다. BGP 를 지원하는 라우터가 있어야만 사용할 수 있는 방식이지만, 서비스의 엔드포인트가 2 개 이상의 노드에 있는 경우에도 라우터가 지원하는 로드밸런싱 기능을 이용하여 트래픽을 분산 처리할 수 있다.\n오픈소스 라우팅 데몬인 BIRD 를 이용하여 MetalLB 의 BGP 모드를 간단히 검증하였다. 아래는 외부 트래픽 정책을 로컬로 설정했을 때 BIRD 가 설치된 노드의 라우팅 테이블이다. 브로커의 외부 주소는 각각 브로커 파드가 동작 중인 노드의 주소로 설정되어 있고, 부트스트랩의 외부 주소는 모든 브로커 파드가 동작 중인 세 개 노드의 주소로 설정되어 있다.\n\n아래는 외부 트래픽 정책을 클러스터로 설정했을 때 BIRD 가 설치된 노드의 라우팅 테이블이다. 모든 노드를 통해서 모든 파드로 접속할 수 있기 때문에 모든 외부 주소는 모든 노드의 주소로 설정되어 있는 것을 볼 수 있다.\n\n그리고 노드로 들어온 요청을 브로커로 전달하는 과정은 앞의 경우와 동일하다.\n쿠버네티스와 같은 클러스터 환경에서는 불필요한 네트워크 홉을 줄이는 것이 매우 중요하기 때문에 워크로드의 동작 방식을 정확히 파악하여 적절한 네트워크 정책을 적용하는 것이 중요하다.\n","description":"","id":"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/","title":"[K8S] 네트워크 최적화 (MetalLB)"},"https://haruband.github.io/k8s-memory-swap/":{"body":"쿠버네티스는 기본적으로 메모리 스와핑을 지원하지 않는다. 20년 넘는 시간동안 운영체제 관련 연구/개발을 수행하면서 메모리 스와핑이 만들어내는 다양한 문제들에 대한 연구를 많이 봤었고, 이러한 문제들때문에 메모리 스와핑을 강제로 막는 경우도 많이 봤었기 때문에 딱히 이상하진 않았지만, 다양한 워크로드를 지원하는 범용적인 환경에서 아예 지원하지 않는 것은 조금 이상했었다. 그런데, 최근 쿠버네티스 1.22에서 메모리 스와핑을 지원한다는 기사를 보고 호기심이 생겨 관련 내용을 조사해보니 꽤 오래전부터 지원 여부에 대한 많은 논의가 있었고, 지금은 과거와 달리 여러 가지 문제가 많이 개선된 상황이니 사용자가 선택할 수 있게 해줘야 한다는 분위기가 된 것 같다. 관련 기능은 아직 알파 단계이기 때문에 오늘은 해당 기능에 대한 자세한 설명보다는 해당 기능을 이해하기 위해 필요한 기반 지식을 먼저 소개하도록 하겠다.\n지금은 아니지만, 예전에는 리눅스 커널을 공부하려는 사람들이 많았었고, 이들이 가장 힘겨워하는 부분이 바로 메모리 관리였다. 그리고 이 메모리 관리에서 가장 핵심적인 부분이 페이징인데, 사실 개념은 간단하지만 리눅스 커널 코드 레벨에서 해당 기능을 정확히 이해하기 위해서는 x86 보호모드 및 MMU 기능부터 상당히 복잡한 많은 지식이 필요하다. 운영체제를 공부하다보면 늘 듣는 사용자 프로세스는 커널 주소 공간에 접근할 수 없다, 메모리를 미리 읽지 않고 사용 시점에 읽어들인다 등등이 모두 보호모드와 페이징에 기반하여 구현된다. 하지만 리눅스 커널 개발에 참여할 계획이 없다면 이렇게 자세한 내용까지 알 필요는 없으니 간단히 개념적인 부분에 대해서만 이해하고 다음 단계로 넘어가보도록 하자.\n페이징은 간단히 얘기하면 메모리를 일정한 크기의 페이지(보통 4KB)로 나누어 관리하자는 것이다. 왜 이렇게 해야하지라는 생각이 들면, 페이징없이 수많은 프로세스가 다양한 크기의 메모리를 할당하고 해제하는 과정을 한번 상상해보자. 조만간 메모리는 엄청난 단편화가 발생하여 실제 가용한 메모리가 많더라도 연속적인 메모리를 할당하기 힘든 지경에 이를 것이다. 그렇다면 이러한 문제를 페이징은 어떻게 해결하고 있을까? 바로 아래의 두 가지가 핵심 포인트이다.\n\n물리 메모리에 직접 접근하지 않고 가상 메모리 주소를 통해 물리 메모리에 접근한다. (물리적으로 연속적이지 않더라도 가상적으로는 연속적으로 보이게 만들겠다는 것이다.)\n가상 메모리와 물리 메모리를 동일한 크기의 페이지로 나누어 관리한다. (페이지 단위로 할당/해제를 반복함으로써 단편화 문제를 해결하겠다는 것이다.)\n\n언제나 연속적인 메모리 공간을 확보하는 것이 메모리 관리의 핵심이고, 페이징은 이를 위해 동일한 크기의 페이지를 사용하여 단편화 문제를 해결하였고, 물리 메모리 주소로 바로 접근하는 것이 아닌 가상 메모리 주소를 사용함으로써 연속성 문제를 해결하였다.\n이제 이러한 페이징을 지원하는 리눅스 커널에서 프로세스의 메모리를 어떻게 관리하는지 살펴보자. 위에서 언급했던 것처럼 메모리는 페이지 단위로 관리된다. 그리고 페이지는 크게 두 가지 형태로 사용된다. 첫 번째는 파일의 버퍼로 사용되는 페이지 캐시이고, 두 번째는 힙과 스택 등의 용도로 사용되는 익명 페이지이다. 좀 더 이해하기 쉽게 설명하자면, 어떤 프로그램을 실행하면 해당 프로그램의 코드는 페이지 캐시에 저장되어 실행되고, 해당 프로그램 안에서 malloc() 을 호출하여 메모리를 요청하면 익명 페이지를 할당받아 사용한다는 것이다. 그래서 페이지 캐시와 익명 페이지의 가장 큰 차이는 페이지 캐시는 원본 데이터가 파일에 저장되어있기 때문에 필요시 반환하고 언제든 다시 할당받아 사용할 수 있다는 것이다.\n지금까지 메모리 스와핑을 이해하기 위해 필요한 기반 지식을 소개하였으니 본격적으로 메모리 스와핑에 대해 알아보도록 하자. 메모리는 디스크보다 훨씬 비싼 자원이기 때문에 우리는 항상 메모리 부족 현상을 겪는다. 그렇다면 리눅스 커널은 메모리가 부족할 때 어떻게 이를 해결하려고 할까? 크게 보면 두 가지의 정책이 있다. 첫 번째는 우선 순위가 낮은 프로세스를 죽여서 필요한 메모리를 확보하는 것(OOM)이고, 두 번째는 최근에는 사용되지 않는 페이지를 반환하는 것(LRU)이다. 다들 예상할 수 있듯이, 메모리 스와핑은 바로 두 번째 정책과 관련이 있다.\n그렇다면 사용 중인 페이지를 어떻게 반환할까? 그리고 최근에 사용되지 않았을 뿐이지 혹시라도 다시 사용이 된다면 이를 어떻게 처리할까? 위에서 살짝 언급했던 것처럼 페이지 캐시는 파일의 버퍼이기 때문에 이에 대한 처리가 간단하다. 페이지 캐시의 내용이 수정되지 않았다면 바로 반환하고 필요할 때 다시 읽어들이면 되고, 만약 내용이 수정되었다면 수정된 내용을 반영한 다음 반환하면 된다. 하지만 익명 페이지는 어떻게 할까? 이때 사용되는 것이 바로 메모리 스와핑이다. 익명 페이지는 메모리에만 존재하는 데이터이기 때문에 페이지를 반환하기 위해서는 해당 내용을 어딘가에 저장해야하고 이때 사용되는 공간이 바로 스왑이다. 즉, 익명 페이지를 반환하게 되면 스왑에 해당 내용을 저장하고 반환한다. 그리고 다시 필요해지면 새로운 페이지를 할당받아 스왑에서 해당 내용을 읽어들인 후에 사용한다.\n이제 메모리 스와핑이 어떤 문제를 가지고 있고, 왜 사용을 막아놓았는지 알아보자. 주로 언급되는 문제들은 아래와 같다.\n\n디스크의 입출력 속도(특히, HDD)와 관련 리눅스 커널의 복잡도로 인해 속도가 느리다.\n어떤 페이지가 반환될지 예상할 수 없기에 전반적인 성능에 대한 불확실성이 높아진다.\n...\n\n이러한 문제들로 인해 쿠버네티스는 메모리 스와핑을 막아두었고, 메모리가 부족할때는 QoS 정책에 따라 파드를 죽이는 정책만을 제공하였다. 하지만 아래와 같이 여러 가지 상황의 변화와 반론으로 인해 메모리 스와핑을 지원하기로 한 것이다.\n\n디스크의 입출력 속도(SSD/NVMe)가 개선되었고, 관련 리눅스 커널의 최적화가 진행되었다.\n메모리 스와핑을 지원하더라도 cgroups 를 통해 QoS 관리가 용이해지고 있다.\n메모리 스와핑을 지원하지 않더라도 페이지 캐시 반환으로 인해 성능에 대한 불확실성은 높아진다.\n메모리 사용량은 많지만 반복적으로 사용되는 메모리 사용량이 적은 경우에는 메모리 스와핑이 필수이다.\n...\n\n이와 같은 다양한 개선 사항과 사례 분석을 통해 결국은 쿠버네티스에서도 메모리 스와핑을 지원하게 되었고, 개인적으로도 관련 기술들이 꾸준히 발전하고 있기 때문에 파드 별로 메모리 스와핑을 설정할 수 있는 기능을 제공하고 사용자가 알아서 사용하는 형태가 바람직하다고 보고 있다.\n","description":"","id":"https://haruband.github.io/k8s-memory-swap/","title":"[K8S] 메모리 스와핑 지원 분석"},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"body":"오늘은 지난 글에서 소개했던 NAT 루프백 문제에 대해 다시 소개하고자 한다. 이유는 몇 개 국가의 IDC 혹은 클라우드에서 NAT 루프백 문제를 해결하기 위해 라우터에 필요한 설정을 추가했음에도 불구하고 원인을 정확히 알 수 없는 이유로 동작하지 않는 문제가 발생해서 다른 해결책을 찾을 필요가 있었기 때문이다.\n외부 환경에 의존하지 않고 우리 스스로 해당 문제를 해결할 수 있는 방법은 클러스터 내부에서 외부 IP 를 사용하지 않는 것이다. 이를 위해 우리가 선택할 수 있는 옵션은 첫 번째는 내부 DNS 를 사용하는 것이고, 두 번째는 eBPF (혹은 IPTables) 를 사용하여 외부 IP 로 나가는 모든 패킷을 강제로 내부 IP 로 전달(redirection)하는 것이다. 그리고 해당 문제는 파드에서 외부 IP 를 접근하는 경우 뿐 아니라, 호스트 네트워크를 사용하는 파드나 Kubelet 에서 외부 IP 를 접근하는 경우도 고려할 필요가 있을 수 있다. (우리 같은 경우는 클러스터 내부에 컨테이너 레지스트리 서버를 운영 중이고, Kubelet 에서 컨테이너 이미지를 가져올 때 컨테이너 레지스트리 서버의 외부 도메인 주소를 이용하고 있었다.)\n일반적으로 외부 IP 로 접근하면 NodePort 혹은 LoadBalancer 서비스 타입을 사용하는 인그레스게이트웨이(ingressgateway)를 통해 클러스터 내부 서비스로 요청이 전달된다. 이는 클러스터 내부에서 외부 IP 로 접근할 때도 동일한데, 위의 두 가지 방법으로 외부 IP 를 강제로 내부 IP 로 변경해버리면 인그레스게이트웨이를 통하지 않고 직접 클러스터 내부 서비스에 접근하는 것이기 때문에 호스트 네트워크를 사용하는 파드나 Kubelet 에서는 문제가 발생한다. 이는 다른 글에서 소개했던 소켓 기반 로드밸런싱 기능을 이용하면 해결할 수 있는데, 소켓 기반 로드밸런싱은 아래와 같이 각 노드의 루트 CGROUP 부터 모든 CGROUP 의 소켓 시스템콜에 연결된 BPF 프로그램을 통해 동작하기 때문에 이를 이용하면 호스트 네트워크에서도 클러스터 내부 서비스에 직접 접근이 가능해진다.\n\n우선 내부 DNS 를 사용하는 경우를 살펴보자. 가장 간단한 방법은 모든 노드의 /etc/hosts 를 이용하여 외부 도메인 주소를 강제로 내부 IP 로 변경해버리는 것이다. 하지만 이는 IP 만 변경해주는 것이기 때문에 외부에서 접근하는 포트와 내부에서 접근하는 포트가 다른 경우에는 사용할 수 없다.\n다음은 Cilium 에서 제공하는 LRP(LocalRedirectPolicy) 라는 기능을 사용하는 경우이다. 이는 Cilium 에서 다양한 쿠버네티스 서비스를 BPF 를 이용하여 처리하는 것과 동일한 방식으로 외부 IP 에 대한 요청을 내부 IP 로 전달한다. 아래는 특정 IP(10.10.10.10)와 포트(8080)에 대한 요청을 클러스터 내부에 설치된 파드(nginx)로 전달하는 설정을 담고 있다.\n\n해당 CRD 를 설치한 다음 Cilium 의 서비스 목록을 확인해보면 아래와 같다.\n\n위의 서비스 목록을 보면 10.10.10.10:8080 으로 들어온 요청을 NGINX 엔드포인트인 192.168.0.80:80 으로 전달하는 항목(8번)이 보인다. 실제로 임의의 노드의 호스트에서 10.10.10.10:8080 으로 접속하면 아래와 같이 NGINX 의 인덱스 페이지를 가져오는 것을 볼 수 있다.\n\n이처럼 NAT 루프백 문제가 발생하면 네트워크 관리자에게 SNAT 설정을 요청하는 것이 일반적이긴 하지만, 상황에 따라 다른 해결책이 필요한 경우도 있으니 참고하기 바란다.\n","description":"","id":"https://haruband.github.io/k8s-nat-loopback-lrp/","title":"[K8S] NAT 루프백 문제 분석 (LRP)"},"https://haruband.github.io/k8s-nat-loopback-snat/":{"body":"오늘은 어떤 국가의 지역 클라우드 서비스를 이용하여 쿠버네티스 클러스터를 구축하던 중 발생했던 NAT 루프백 문제(Hairpin NAT)를 파악하고 해결했던 과정에 대해 간단히 소개하고자 한다. 일반적으로는 크게 신경쓰지 않아도 되는 문제인데, 해당 국가의 클라우드 서비스의 설정 오류로 예상치 못하게 문제가 발생하였다.\n어떠한 문제가 발생했는가???\n필요한 가상머신을 몇 개 할당받고 kubespray 로 쿠버네티스를 설치한 후, 관련 서비스들을 모두 배포하고나서 mongodb, minio, kafka 등이 잘 동작하는 것을 확인한 다음, 클러스터 내부에 있는 젠킨스에서 몇 가지 컨테이너 이미지를 빌드한 후 클러스터 내부 레지스트리로 배포하려고 하는데 갑자기 로그인이 되지 않는 문제가 발생하였다. 레지스트리는 https 를 사용 중이어서 외부 도메인 주소를 이용하여 접근하였다. 다른 모든 서비스는 잘 동작 중이었고, 외부에서는 클러스터 내부 레지스트리로 로그인이 잘 되었기 때문에 내부에서 외부 도메인 주소로 접근하는 것에 문제가 있다고 판단하였다. 지금까지 상황에 대해 간단히 정리해보면 다음과 같다.\n\n클러스터 내부 IP 주소(Pod/Service)로는 아무 문제 없이 통신이 가능하다.\n외부에서 클러스터 외부 IP 주소로는 아무 문제 없이 통신이 가능하다.\n내부에서 클러스터 외부 IP 주소로만 통신이 불가능하다.\n\n클라우드의 라우터 설정을 열람할 수 없는 상황이어서 정확히 판단할 수는 없었지만, NAT 루프백 문제라고 충분히 의심할 수 있는 상황이었다.\n어떻게 문제가 발생했는가???\nNAT 루프백 문제인지 정확히 파악하기 위해, node2 에서 node1 의 외부 IP 주소로 curl 을 이용하여 접속할 때 패킷이 전달되는 과정에 대해 자세히 분석해보았다.\n클러스터 노드 IP 설정은 다음과 같다고 가정해보자.\n\nnode1 내부 IP 192.168.10.100\nnode2 내부 IP 192.168.10.101\n라우터 내부 IP 192.168.10.1\n\n그리고 라우터에 설정된 DNAT 설정은 다음과 같다고 가정해보자.\n\n169.233.100.10 ==&gt; 192.168.10.100\n169.233.100.11 ==&gt; 192.168.10.101\n\n이제 node2 에서 node1 로 패킷이 전달되는 과정을 살펴보자.\n\nnode2 에서 출발지 주소(192.168.10.101)와 목적지 주소(169.233.100.10)인 패킷을 송신한다.\n라우터에서 DNAT 설정에 의해 목적지 주소를 192.168.10.100 으로 변경한다.\nnode1 에서 출발지 주소(192.168.10.101)와 목적지 주소(192.168.10.100)인 패킷을 수신한다.\nnode1 에서 출발지 주소(192.168.10.100)와 목적지 주소(192.168.10.101)인 응답 패킷을 송신한다.\nnode2 에서 출발지 주소(192.168.10.100)와 목적지 주소(192.168.10.101)인 응답 패킷을 수신한다.\n\n위의 과정을 살펴보면, node2 에서는 출발지 주소(192.168.10.101)와 목적지 주소(169.233.100.10)로 소켓이 생성되어있는데 응답 패킷의 출발지 주소가 169.233.100.10 이 아닌 192.168.10.100 이기 때문에 응답 패킷을 받지 못하는 문제가 발생한 것이다. 이는 node1 에서 송신한 응답 패킷의 목적지 주소가 192.168.10.101 이기 때문에 응답 패킷이 라우터의 DNAT 역변환 과정을 거치지 않고 바로 node2 로 전달된 것이 원인이다. 즉, 전형적인 NAT 루프백 문제인 것을 확인하였다.\n어떻게 문제를 해결했는가???\n해당 문제를 해결할 수 있는 방법은 두 가지 정도이다.\n\n라우터 SNAT 설정 추가\n내부 DNS 설정 추가\n\n첫 번째가 보편적으로 사용되는 NAT 루프백을 해결하는 방식이다. 우리도 첫 번째 방식으로 라우터에 SNAT 설정을 추가하여 해당 문제를 해결하였다. 라우터에 SNAT 설정을 추가한 경우 패킷이 어떻게 전달되는지 살펴보자.\n\nnode2 에서 출발지 주소(192.168.10.101)와 목적지 주소(169.233.100.10)인 패킷을 송신한다.\n라우터에서 DNAT 설정에 의해 목적지 주소를 192.168.10.100 으로 변경한다.\n라우터에서 SNAT 설정에 의해 출발지 주소를 192.168.10.1 으로 변경한다.\nnode1 에서 출발지 주소(192.168.10.1)와 목적지 주소(192.168.10.100)인 패킷을 수신한다.\nnode1 에서 출발지 주소(192.168.10.100)와 목적지 주소(192.168.10.1)인 응답 패킷을 송신한다.\n라우터에서 SNAT 설정에 의해 목적지 주소를 192.168.10.101 으로 변경한다.\n라우터에서 DNAT 설정에 의해 출발지 주소를 169.233.100.10 으로 변경한다.\nnode2 에서 출발지 주소(169.233.100.10)와 목적지 주소(192.168.10.101)인 응답 패킷을 수신한다.\n\n이처럼 라우터에 SNAT 설정을 추가하여 응답 패킷을 무조건 라우터가 먼저 받게하면 필요한 역변환 과정을 거치게 되어 해당 문제는 깔끔하게 해결된다. 혹시 라우터를 조작하기 힘든 경우에는 두 번째 해결 방식도 가능하다. 이는 내부 DNS 에 해당 도메인을 외부 IP 주소가 아닌 내부 IP 주소로 등록하여 불필요한 DNAT/SNAT 과정을 거칠 필요가 없게 만드는 것이다.\n","description":"","id":"https://haruband.github.io/k8s-nat-loopback-snat/","title":"[K8S] NAT 루프백 문제 분석 (SNAT)"},"https://haruband.github.io/k8s-networkpolicy/":{"body":"오늘은 최근 회사에서 GitOps 를 적용하기 위해 ArgoCD 를 설치하던 중 발생했던 네트워크 정책(NetworkPolicy) 관련된 문제에 대해 살펴보고자 한다.\n어떠한 문제가 발생했는가???\nHelm 을 이용하여 ArgoCD 를 설치하였는데 아래와 같이 두 개의 파드만 동작하지 않는 문제가 발생하였다.\n\n아래와 같이 동작 확인(readiness/liveness)이 제대로 되지 않는 문제였고, 직접 호스트에서 확인해보니 파드로 네트워크 연결이 되지 않았다.\n\n나머지 파드는 모두 잘 동작하는데 왜 두 개의 파드만 네트워크 연결이 안 되는 것일까?\n우선 라우팅 정책을 살펴보도록 하자. 아래와 같이 라우팅 정책에는 문제가 없었다. Cilium 이 제공하는 엔드포인트 라우팅을 사용 중이기 때문에 VETH 마다 라우팅 정책이 설정되어 있다.\n\n다음으로 네트워크 정책을 살펴보도록 하자. 아래는 ArgoCD 에서 문제가 발생한 파드를 위해 제공하는 네트워크 정책과 Cilium 이 해당 정책을 eBPF 를 이용하여 적용한 내용이다. 해당 네트워크 정책은 8082/TCP 포트로만 접근을 허용하고 있고, Cilium 이 적용한 정책 테이블의 ID(Identity) 값을 보면 모든 파드와 호스트에서만 접근을 허용하고 있다. (Host 의 ID 가 1 이다.)\n\n기본적인 설정에는 별 문제가 없어보이니 Cilium 이 제공하는 모니터링 기능을 이용하여 확인해보자.\n\n위에서 볼 수 있는 것처럼 호스트에서 파드로 보낸 패킷이 Cilium 에 의해 드롭되고 있었다. 이유는 해당 패킷의 ID 가 World 로 되어있기 때문이다. (World 는 클러스터 외부를 의미하고, ID 는 2 이다.) 분명히 호스트(Host)에서 패킷을 보냈는데 왜 클러스터 외부(World)에서 보낸 것으로 인식하는 것일까? 그리고 왜 두 개의 파드만 동작하지 않고 나머지 파드는 동작하는 것일까?\n우선 두 번째 의문점을 해결하기 위해 동작 중인 파드가 사용 중인 네트워크 정책을 살펴보자.\n\n위에서 볼 수 있는 것처럼 동작 중인 파드는 네트워크 정책이 비어있기 때문에 모든 접속을 허용하고 있다. (Cilium 은 모든 접속을 허용하기 위해 ID 가 0 인 항목을 추가하였다.) 그래서 아래와 같이 호스트에서 보낸 패킷의 ID 가 World 로 인식되어도 문제없이 동작하는 것이다.\n\n그럼 이제 첫 번째 의문점인 왜 Cilium 이 호스트에서 보낸 패킷을 클러스터 외부에서 보낸 패킷으로 인식하는지 살펴보자.\n어떻게 문제가 발생했는가???\nCilium 은 0xc00 이 마킹되어 있는 패킷을 호스트에서 보낸 패킷으로 인식하는데, 호스트에서 보낸 패킷에 0xc00 을 마킹하기 위해 IPTables 를 사용하고 있다. 그런데 IPTables 에 필요한 정책을 추가하는 설정(--install-iptables-rules)이 해제되어 있어서 제대로 마킹이 되지 않았던 것이다.\n어떻게 문제를 해결했는가???\n해결책은 간단하다. 필요한 설정(--install-iptables-rules)을 추가하면 된다. 해당 설정을 추가하고 IPTables 에 추가된 정책을 살펴보자.\n\n호스트에서 직접 보내는 패킷에 0xc00 을 마킹하는 룰(CILIUM_OUTPUT 체인의 2 번째)을 볼 수 있다. 그리고 다시 Cilium 으로 모니터링을 해보면 결과는 아래와 같다.\n\n호스트에서 보낸 패킷의 ID 가 정상적으로 Host 로 인식되는 것을 볼 수 있다.\n","description":"","id":"https://haruband.github.io/k8s-networkpolicy/","title":"[K8S] Cilium NetworkPolicy 문제 분석"},"https://haruband.github.io/k8s-proxy-bypass/":{"body":"오늘은 Cilium 에서 소켓 기반 로드밸런싱을 이용할 때 발생하는 EnvoyProxy 사이드카 우회 문제에 대해 살펴보고자 한다. 이는 현재 모든 서비스 메쉬(Istio, Linkerd, ...)에서 서비스 IP 기반으로 동작하는 모든 필터를 우회하는 심각한 문제를 유발하고 있다. 왜 이런 문제가 발생했는지 살펴보고, 몇 가지 해결 방안을 소개하도록 하겠다.\n우선 Cilium/Istio 에서 EnvoyProxy 사이드카가 동작하는 원리를 간단히 살펴보자. 아래 그림은 서비스 컨테이너에서 전송하는 패킷의 이동 경로(1-11번까지)를 간단히 표현한 것이다.\n\nIPTables 를 이용하는 사이드카 기반의 모든 프록시가 대부분 비슷한 방식으로 동작하는데, 서비스 컨테이너에서 전송하는 모든 패킷은 Netfilter 에서 강제로 프록시(envoy) 컨테이너로 전달된다. 그리고 프록시 컨테이너에서 등록된 정책에 따라 해당 패킷을 드롭하거나, 지연시키거나, 변환한다. 이때 사용되는 정책은 헤드리스와 같이 특이한 경우를 제외하고는 모두 서비스 IP 를 기반으로 만들어진다.\n다음으로 Cilium 에서 로드밸런싱이 일어나는 과정에 대해 간단히 살펴보자. 일반적인 로드밸런싱은 위 그림의 10번 단계에서 일어난다. 파드 내부의 네트워크 장치(eth0)와 VETH 로 연결된 호스트 네트워크 장치(veth0)의 ingress BPF 프로그램에서 서비스 IP 를 백엔드 IP 로 변환하여 패킷을 전달한다. 이는 모든 패킷에 대해 주소 변환 및 역변환 작업을 해야하는 문제가 있는데, 이를 해결하기 위해 나온 것이 바로 소켓 기반 로드밸런싱이다. 이는 위 그림의 2번 단계에서 소켓 시스템콜(connect, sendto)에 연결된 BPF 프로그램이 서비스 IP 를 백엔드 IP 로 변환하여 소켓의 목적지 주소를 미리 변경해놓는 방식이다. 이를 통해 매번 패킷의 목적지 주소를 변환/역변환하는 오버헤드를 줄일 수 있다.\n이쯤되면 다들 눈치를 챘겠지만, Cilium&nbsp;에서 소켓 기반 로드밸런싱을 이용할 경우 2번 단계에서 이미 서비스 IP 가 백엔드 IP 로 변환되었기 때문에 당연히 서비스 IP 기반으로 동작하는 프록시 컨테이너는 제대로 작동할 수가 없는 것이다.\n하지만 Istio/Envoy 에서는 예외적인 경우가 있는데, TCP 필터를 사용할 때는 설명했던 문제가 발생하지만 HTTP 필터를 사용할 때는 문제가 발생하지 않는다. 이는 Envoy 의 HTTP 필터가 HTTP 패킷의 Host 헤더를 이용해서 필터링을 수행하기 때문에 패킷의 목적지 주소가 서비스 IP 에서 백엔드 IP 로 변환되어 있어도 문제가 되지 않는 것이다.\n오늘 소개한 문제를 해결하기 위한 몇 가지 방법을 소개하도록 하겠다.\n첫 번째로 지금 현재 바로 사용 가능한 방법은 소켓 기반 로드밸런싱을 아예 사용하지 않는 것이다. 약간의 오버헤드는 있지만 가장 간단하고 확실한 방법이다. 두 번째는 호스트에서만 소켓 기반 로드밸런싱을 사용하거나, 프록시 컨테이너를 사용 중인 파드에서만 소켓 기반 로드밸런싱을 사용하지 못 하게 하는 것인데 이는 아직 Cilium 개발자 커뮤니티에서 논의 중인 기능이기 때문에 당장은 사용할 수 없다. 세 번째는 프록시 컨테이너에서 변환 전의 서비스 IP 를 확인 할 수 있는 기능을 제공하는 것인데 이 또한 현재 Cilium 과 Istio/Linkerd 개발자들이 논의 중에 있다.\n참고로, 첫 번째 방식을 사용할 때 주의해야 할 점이 있는데, KubeProxyReplacement 옵션이 probe 이거나 strict 이면 소켓 기반 로드밸런싱 기능은 해제가 되지 않는다. 해당 옵션을 꺼도 자동 탐지 기능에 의해서 다시 켜지니 주의하기 바란다.\n","description":"","id":"https://haruband.github.io/k8s-proxy-bypass/","title":"[K8S] Cilium Socket-based LoadBalancing 에 의한 Istio Envoy 우회 문제 분석"},"https://haruband.github.io/k8s-qos-memory/":{"body":"쿠버네티스처럼 다양한 워크로드를 제한된 자원을 이용하여 효율적으로 실행해야하는 플랫폼에서는 QoS 의 역할과 보장이 매우 중요하다. 특히 성능에 큰 영향을 주는 메모리 관리는 무엇보다 중요하며, 최근 CGroupV2 와 스왑 지원으로 메모리 관리 기능이 점점 더 강화되고 있다. 오늘은 이러한 기능들을 이용하여 쿠버네티스가 어떻게 메모리를 관리하는지 자세히 살펴보도록 하자. (리눅스 커널이 제공하는 메모리 관리의 핵심적인 기능인 페이징과 스왑에 대해 궁금하신 분은 관련 글을 먼저 읽어보기 바란다.)\nQoS 의 가장 핵심적인 기능은 주어진 만큼만 자원을 사용토록 하는 것이다. 이는 CPU 같이 압축(compressible)이 쉬운 자원은 문제가 안 되지만, 메모리처럼 압축이 어려운 자원은 생각보다 고려해야 할 사항이 많다. 메모리가 압축이 어려운 대표적인 이유는 1) 페이지 캐시처럼 여러 프로세스가 공유하는, 소유자가 애매한 경우가 많고, 2) 커널 메모리처럼 반환이 불가능하거나, 페이지 캐시나 익명 페이지처럼 반환이 어려운 경우가 많기 때문이다. 이러한 문제들로 인해 쿠버네티스에서 CGroupV2 와 스왑의 역할이 더욱 중요해지고 있다.\n어떻게 프로세스가 사용하는 메모리를 제한하는가?\n쿠버네티스는 리눅스 커널이 제공하는 CGroupV2 를 이용하여 프로세스가 속해있는 CGROUP 단위로 메모리 사용량을 제한하고 있다. 리눅스 커널이 프로세스의 메모리 사용량을 제한하는 핵심적인 방법은 메모리를 할당할 때마다 사용량을 확인해서 필요하면 바로 반환하는 것이다. 아래는 페이징을 지원하는 리눅스 커널에서 페이지 폴트가 발생할 때 새로운 페이지를 할당받는 과정을 간단히 정리한 것이다. (이외에도 페이지를 할당받는 방법이 있긴 하지만, 대부분은 아래와 같은 방식으로 페이지를 할당받는다.)\n\n새로운 페이지를 할당받는다. (익명 페이지 혹은 페이지 캐시)\n프로세스가 속해있는 CGROUP 의 메모리 사용량을 확인한다.\n메모리 초과 사용시, 초과된 메모리를 모두 반환한다. (몇 가지 정책(LRU, swappiness, ...)에 의해 선택된 페이지를 반환한다.)\n메모리 반환 실패시, 해당 프로세스는 종료(OOM)된다.\n\n리눅스 커널에서 초과된 메모리를 반환하는 것이 쉬운 일은 아니지만, 위와 같이 굉장히 간단하고 강력한 수단으로 메모리 사용량을 제한하고 있다.\n어떻게 시스템이 사용하는 메모리를 제한하는가?\n프로세스의 메모리 사용량을 아무리 잘 제한하더라도 시스템 전체의 메모리 사용량은 한도를 초과할 수 있다. 그래서 이를 해결하기 위해 리눅스 커널은 1) 필요할 때마다 메모리 접근 시점을 기반으로 하는 LRU 정책을 이용하여 메모리를 반환하고, 2) 전체 메모리 사용량이 한도를 초과하면 우선순위를 계산해서 특정 프로세스 혹은 특정 CGROUP 을 종료시킨다. 또한, 쿠버네티스도 전체 메모리 사용량이 한도를 초과했을 때 자체적으로 우선순위를 계산해서 특정 파드를 종료시킨다.\n어떻게 프로세스가 사용 중인 메모리를 반환하는가?\n프로세스가 사용 중인 메모리를 강제로 반환하는 것은 쉬운 일이 아니다. 파일에 대한 빠른 접근을 위해 사용되는 페이지 캐시는 수정된 내용이 없으면 추가적인 작업없이 바로 반환할 수 있지만, 수정된 내용이 있으면 반드시 원본 파일에 해당 내용을 반영(writeback)한 후 반환할 수 있다. 스택이나 힙을 위해 사용되는 익명 페이지는 스왑 기능이 없으면 반환이 아예 불가능하며, 스왑 기능이 있으면 익명 페이지를 위한 스왑 공간을 할당받고 페이지 내용을 저장한 후 반환할 수 있다. 그리고 페이지 캐시의 수정된 내용을 반영(writeback)하거나 익명 페이지를 스왑에 저장하기 위해서는 디스크에 대한 쓰기 작업이 필요하기 때문에 예상치 못한 문제가 발생할 수도 있고, 프로세스의 메모리 사용 패턴에 따라 메모리를 반환하는 것이 성능에 큰 영향을 줄 수도 있다.\n간단히 몇 가지 실험을 통해 최대 메모리 사용량이 페이지 캐시와 익명 페이지에 어떤 영향을 주는지 살펴보도록 하자.\n우선 페이지 캐시부터 살펴보도록 하자. 아래는 1G 메모리를 사용할 수 있는 프로세스가 4G 파일을 두 번째 읽을 때의 상황이다. (페이지 캐시의 효과를 보려면 읽은 파일을 다시 읽어야 한다.)\n\n4G 파일을 이미 순차적으로 한번 읽었지만 1G 메모리만 사용할 수 있기 때문에 마지막에 읽은 1G 메모리만 페이지 캐시에 남아있다. 그래서 해당 파일을 다시 순차적으로 읽을 때는 파일 전체를 다시 읽을 수 밖에 없기 때문에 성능이 매우 떨어질 수 밖에 없다. 하지만, 해당 프로세스가 8G 메모리를 사용할 수 있다면 상황은 아래와 같이 많이 다를 것이다.\n\n4G 파일을 처음 읽고나면 4G 메모리가 모두 페이지 캐시에 남아있기 때문에 두번 째 읽을 때는 파일을 다시 읽을 필요가 없으므로 성능이 상대적으로 매우 좋을 수 밖에 없다.\n다음은 익명 페이지를 살펴보도록 하자. 아래는 스왑 기능이 없을때 1G 메모리를 사용할 수 있는 프로세스가 4G 힙을 사용할 때의 상황이다.\n\n부족한 메모리를 반환해서 사용할 수 없기 때문에 리눅스 커널에 의해 해당 프로세스는 바로 종료된다. 하지만, 스왑 기능이 있다면 상황은 아래와 같을 것이다.\n\n메모리가 부족할 때마다 익명 페이지를 반환해서 사용하기 때문에 프로세스가 종료되진 않지만, 스왑 공간에 대한 디스크 쓰기 작업이 꾸준히 발생하는 것을 볼 수 있다.\n스왑 기능이 반드시 필요한가?\n스왑 기능이 없다면, 반복적으로 사용되지 않는 스택이나 힙이 많을때는 프로세스가 종료될 때까지 많은 메모리가 낭비될 수 있고, 프로세스가 사용하는 스택이나 힙의 크기를 예측하기 힘들때는 예상치 못하게 프로세스가 종료될 수 있다. 그래서 모든 프로세스가 스왑 기능이 필요한 것은 아니지만, 스왑이 반드시 필요한 프로세스도 많기 때문에 선택적으로 사용할 수 있어야 한다.\n페이지 캐시는 누구의 소유인가?\n스택과 힙에 사용되는 익명 페이지는 해당 프로세스의 소유이지만, 페이지 캐시는 누구나 사용할 수 있기 때문에 어떤 프로세스의 소유인지가 애매하다. 현재 리눅스 커널은 간단히 페이지 캐시에 처음 접근해서 페이지를 할당받은 프로세스의 소유로 하고 있다. 그래서 페이지 캐시를 처음 접근할수록 불리할 수도 있다. 왜냐하면 다른 프로세스도 사용하는데 해당 프로세스의 메모리 사용량만 줄어들기 때문이다.\n주의해야할 사항\n높은 우선순위를 가진 파드도 커널에 의해 종료될 수 있다. 시스템 전체의 메모리가 부족해서 실행되는 커널이나 쿠버네티스의 OOM 에 의해 종료되진 않겠지만, 스왑 기능 없이 스택이나 힙을 과도하게 사용한다면 언제든 종료될 수 있다. 그래서 우선순위를 높이기 위해 최대 메모리 사용량을 명시할 때는 신중히 설정해야 한다.\n높은 우선순위를 가진 파드가 낮은 우선순위를 가진 파드에 의해 방해받을 수 있다. 리눅스 커널은 여러 가지 상황에서 일부 메모리를 반환하기 시작하는데, 이때 루트 CGROUP 부터 PRE-ORDER 방식으로 순회하면서 LRU 정책에 의해 반환하기 때문에 우선순위가 높은 파드의 최근 사용되지 않은 페이지가 반환될 수 있다.\n낮은 우선순위를 가진 파드가 메모리를 반환하기 위해 과도한 디스크 쓰기 작업을 수행하면 병목 현상이 발생할 수 있다. 이를 해결하기 위해 CGroupV2 에는 디스크 읽기/쓰기 한도를 설정할 수 있는 기능이 있지만, 아직 쿠버네티스는 이를 활용하고 있지 않다.\n","description":"","id":"https://haruband.github.io/k8s-qos-memory/","title":"[K8S] 메모리 QoS 지원 분석"},"https://haruband.github.io/k8s-rpfilter/":{"body":"리눅스는 패킷의 출발지 주소를 마음대로 조작해서 공격하는 IP 스푸핑 공격을 막기위해 RPFilter (Reverse Path Filter) 라는 기능을 제공한다. 이 기능은 간단히 소개하면 특정 네트워크 장치로 들어온 패킷이 동일한 네트워크 장치로 나갈 수 있는지를 확인하는 것인데, 이는 해당 패킷의 출발지 주소를 목적지 주소로 하는 라우팅 정보(FIB)를 이용하여 확인한다. 오늘은 이 기능으로 인해 발생한 문제에 대해 자세히 살펴보도록 하자.\n어떠한 문제가 발생했는가???\n개발 서버에 쿠버네티스와 Cilium 을 설치하였는데 아래와 같이 coredns 가 동작하지 않는 문제가 발생하였다. 정확한 문제를 파악하기 위해 관련 정보들을 하나씩 분석해보도록 하자.\n\n아래와 같이 원인을 알 수 없는 이유로 상태 확인(readiness/linveness)이 실패하고 있었다. 현재 상황에서 예상해볼 수 있는 것은 상태 확인을 하는 호스트(kubelet)와 파드(coredns) 간의 네트워크에 어떠한 문제가 생긴 것이다. 그래서 호스트와 파드(coredns) 양쪽에서 tcpdump 로 확인해보니, 호스트에서 보낸 패킷을 파드(coredns)에서 받은 후 응답 패킷을 보냈지만 호스트에서는 해당 응답 패킷을 받지 못하였다. 일단 호스트가 파드(coredns)에서 보낸 응답 패킷을 알 수 없는 이유로 드롭하고 있다고 볼 수 있다.\n\n이럴 경우 대부분은 패킷의 잘못된 출발지 주소로 인해 발생하는 마션소스(martian source) 문제이다. 해당 문제가 맞는지 확인해보자.\n\n위와 같이 마션소스 로그를 활성화한 후 커널 로그를 확인해보니 예상대로 관련 로그를 찾을 수 있었다. 위의 로그는 lxc3c160d6c7aa0 네트워크 장치에서 출발지 주소(10.0.0.113)와 목적지 주소(10.0.0.253)인 패킷을 드롭했다는 내용이다. 이제 왜 이 패킷이 드롭되었는지 분석해보도록 하자.\n우선 아래와 같이 파드(coredns)의 네트워크 장치와 연결된 호스트의 네트워크 장치(VETH)를 확인해보자. coredns 의 PID(556675) 를 이용하여 nsenter 로 네트워크 네임스페이스 변경 후 네트워크 장치를 확인해보면 416 번 네트워크 장치를 볼 수 있다.\n\n해당 네트워크 장치의 이름(eth0@if417)은 417 번 네트워크 장치와 연결된 장치라는 의미이고, 아래와 같이 호스트에서 해당 네트워크 장치인 lxc3c160d6c7aa0 를 찾을 수 있다. 즉, 위의 마션소스 로그는 파드(coredns)와 연결된 호스트의 네트워크 장치(lxc3c160d6c7aa0)에서 응답 패킷을 처리하는 동안 발생한 것이다.\n\n그렇다면 왜 호스트의 네트워크 장치(lxc3c160d6c7aa0)에서 해당 응답 패킷을 드롭한 것일까? 이는 처음 소개했던 RPFilter 의 동작 원리를 이용하면 간단히 확인할 수 있다. 아래와 같이 응답 패킷의 출발지 주소(10.0.0.113)를 목적지 주소로 하는 라우팅 정보(FIB)를 확인해보자.\n\n위의 라우팅 정보를 보면 호스트에서 10.0.0.113 으로 패킷을 전송할 때는 10.0.0.253 을 출발지 주소로 이용하여 cilium_host 네트워크 장치로 보낸다는 것을 알 수 있다. 그리고 해당 라우팅 정보가 선택된 이유는 현재 라우팅 테이블이 아래와 같이 구성되어 있기 때문이다. 즉, 목적지 주소가 10.0.0.0/24 인 모든 패킷은 cilium_host 네트워크 장치로 전달된다.\n\n여기까지 분석한 내용들을 정리해보면, 호스트에서 패킷을 보낼 때는 cilium_host 네트워크 장치를 사용했지만, 응답 패킷은 lxc3c160d6c7aa0 네트워크 장치에서 처리하기 때문에 RPFilter 에 의해 해당 응답 패킷이 드롭되는 것이다. 하지만, 패킷을 보내는 장치와 받는 장치가 다른 것은 Cilium 에서는 일반적인 동작 방식 중 하나이기 때문에 Cilium 은 기본적으로 자신이 관리하는 모든 네트워크 장치에서 RPFilter 를 사용하지 않도록 설정해둔다. 즉, 해당 문제는 아래와 같이 Cilium 에서 사용하지 않도록 설정해둔 RPFilter 가 알 수 없는 이유로 사용되면서 발생한 문제이다.\n\n어떻게 문제가 발생했는가???\nCilium 은 새로운 네트워크 장치를 만들 때 마다 RPFilter 를 사용하지 않도록 설정한다. 그런데 왜 RPFilter 가 사용된 것일까? 그 이유는 새로운 네트워크 장치가 추가될 때 마다 UDEV 에 의해 systemd-sysctl 이 실행되는데, 그 때 사용되는 모든 네트워크 장치의 기본 설정이 RPFilter 를 사용하는 것이기 때문이다. 즉, Cilium 에서 새로운 네트워크 장치를 만든 직후 RPFilter 를 사용하지 않도록 설정하지만, 곧이어 UDEV 에 의해 실행되는 systemd-sysctl 이 해당 네트워크 장치의 RPFilter 를 다시 사용하도록 만들어 버린 것이다.\n\n어떻게 문제를 해결했는가???\n해당 문제를 해결할 수 있는 방법 두 가지를 소개하도록 하겠다.\n첫 번째는 Cilium 이 제공하는 엔드포인트 라우팅 기능을 사용하는 것이다. 이 기능을 사용하면 아래와 같이 각각의 엔드포인트를 위한 라우팅 정보가 추가된다. 즉, 목적지 주소가 10.0.0.0/24 인 모든 패킷을 cilium_host 네트워크 장치를 통해 전달하는 것이 아니고, 각각의 목적지 주소에 해당하는 파드와 연결된 네트워크 장치로 패킷을 바로 전달해버리는 것이다.\n\n아래와 같이 파드(coredns)의 주소인 10.0.0.40 이 lxc3b28c7d86cd3 네트워크 장치로 바로 전달되는 라우팅 정보를 확인할 수 있다.\n\n두 번째는 systemd-sysctl 이 사용하는 기본 설정을 변경해버리는 것이다. lxc 로 시작되는 이름을 가진 모든 네트워크 장치의 RPFilter 를 사용하지 않도록 설정해두면 된다.\n\n여기까지 RPFilter 로 인해 발생하는 문제와 해결책에 대해 살펴보았다.\n","description":"","id":"https://haruband.github.io/k8s-rpfilter/","title":"[K8S] Cilium RPFilter 문제 분석"},"https://haruband.github.io/k8s-spark-optimize-swap/":{"body":"대표적인 빅데이터 처리 기술인 스파크(Spark)는 중간 결과를 하둡(Hadoop)처럼 디스크에 저장하지 않고 메모리에만 저장함으로써 놀랄만한 성능 개선을 가져왔다. 하지만 그만큼 메모리 사용량이 늘어났고, 메모리 관리를 어렵게 만들었다. 이는 다양한 서비스들과 스파크를 동시에 운영하는 쿠버네티스(K8S) 환경에서 더 심각한 문제가 될 수 있으며, 오늘은 최근 쿠버네티스에서도 지원하기 시작한 스왑(Swap)을 이용하여 이러한 문제를 어떻게 해결하였는지 소개하고자 한다.\n우선, 리눅스 커널이 메모리를 어떻게 관리하는지 간단히 살펴보자.\n페이지 캐시/버퍼 캐시\n페이지 캐시는 파일의 데이터를 보관하는 메모리이고, 버퍼 캐시는 디렉토리의 파일 목록, 아이노드(Inode) 등을 보관하는 메모리이다. 이는 원본 데이터가 디스크에 있기 때문에 반환이 용이하다. 캐시가 수정되었을 때만 반영(Writeback)을 먼저 해야하고, 수정되지 않았을 때는 바로 반환할 수 있다.\n익명 페이지\n일반적으로 힙(Process/JVM Heap) 영역으로 사용되는 메모리이다. 메모리가 원본 데이터이기 때문에 스왑이 없으면 반환 자체를 할 수 없다. 스왑이 있으면 스왑 영역에 공간을 할당받아서 원본 데이터를 반영(Writeback)한 후 반환할 수 있다. 성능 개선을 위해 중간 결과를 메모리에만 저장하는 스파크가 가장 많이 사용하는 메모리이다.\n커널 메모리\n커널 스택, 페이지 테이블/디렉토리, 슬랩(Slab) 등 커널 내부에서 사용되는 메모리이다. 대부분 반환이 불가능한 메모리이지만, 페이지 캐시와 익명 페이지에 비해 사용량이 매우 적기 때문에 일반적으로는 크게 신경쓰지 않아도 된다.\n다음으로, 쿠버네티스 환경에서 스파크를 운영할 때 메모리 관련해서 발생하는 다양한 문제들에 대해서도 한번 살펴보자.\nJVM OOM(Out-Of-Memory)\n스칼라(Scala)로 개발된 스파크는 JVM 위에서 동작하기 때문에 JVM 이 사용할 최대 힙(Heap)의 크기를 지정해야 한다. 이 값이 실제 최대 사용량보다 작으면 OOM(JVM) 에 의해 해당 작업이 종료되고, 너무 크면 낭비되는 메모리가 많아질 수 있으니 적절한 값으로 설정하는 것이 중요하다.\nCGroup OOM(Out-Of-Memory)\n스파크의 쿠버네티스 스케줄러는 익스큐터(Executor) 파드에 JVM 최대 힙 크기와 메모리 오버헤드 크기 등을 합쳐서 요청량(Requests)과 제한량(Limits)을 적용한다. 그래서 만약 해당 파드가 스왑 없이 익명 페이지를 메모리 한도보다 많이 사용한다면, OOM(CGroup) 에 의해 파드가 종료된다. 파드의 메모리 사용량이 많아지면 지속적으로 메모리를 반환하지만, 스왑이 없으면 익명 페이지는 반환되지 않기 때문이다. (스왑이 있으면 이론적으로는 OOM(CGroup) 은 발생하지 않는다.)\nProcess OOM(Out-Of-Memory)\n시스템의 물리 메모리가 부족해지면 커널에 의해 우선순위(oom_score)를 따라서 특정 프로세스가 종료(OOM)된다. 쿠버네티스는 QoS 정책에 따라 우선순위(oom_score_adj)를 지정하기 때문에, 서비스의 중요도에 따라서 QoS 정책을 잘 세워야만 최악의 상황은 면할 수 있다.\nK8S PodEviction\n시스템의 물리 메모리가 지정된 값보다 작아지면, Kubelet 은 주기적으로 우선순위가 낮은 파드를 종료시킨다. 기본 설정값이 10 초마다 물리 메모리가 100 MBytes 이하일 때 파드를 추출하는 것인데, 우리의 실험 환경에서는 Kubelet 에 의해 파드가 추출되는 경우는 한번도 없었고 모두 커널에 의해 OOM 으로 종료되었다. 기본 설정값을 변경하거나 실험 환경이 다르면 다른 결과를 보일 수도 있겠지만, 이러한 환경에서는 현실적으로 실효성이 없다고 볼 수 있다.\nSystem Overload\n스왑이 없으면 반환되지 않는 익명 페이지 사용량이 지속적으로 증가하면 페이지 캐시를 위한 메모리가 지속적으로 감소한다. 그리고 페이지 캐시가 줄어들면 프로세스가 파일에 접근할 때 디스크에서 다시 읽어들이는 경우가 많아지게 되고, 어느 순간 임계점을 넘어서면 CPU 와 디스크 사용량이 폭발적으로 증가하게 된다. 이 상황에서는 모든 프로세스가 정상적으로 동작할 수 있는 상황이 아니기 때문에, 우리의 실험 환경에서 주로 나타났던 현상은 스파크 익스큐터가 드라이버에게 하트비트(Heartbeat)를 제대로 전송하지 못해서 강제로 재시작되는 경우와 노드가 일정시간(PodEvictionTimeout) 이상 동작불능(NotReady) 상태가 되어 모든 파드가 추출되는 경우이다.\n지금까지 설명한 문제들은 크게 두 가지로 나뉜다. 첫 번째는 파드(익스큐터)에 충분한 메모리를 할당하지 않아서 발생하는 문제들(JVM/CGroup OOM)이고, 두 번째는 전체 메모리 사용량이 시스템의 물리 메모리를 초과해서 발생하는 문제들이다. 두 가지 모두 근본적인 원인은 서비스가 사용하는 메모리를 정확히 계산/예측하는 것이 매우 어렵고, 최대 사용량 이상의 메모리를 할당해야 한다는 것이다. 그래서 문제가 발생하지 않을만큼 파드에 메모리를 할당하고 시스템에 물리 메모리를 추가하는 것이 일반적인 방법이지만, 이는 서비스가 지속적으로 재접근하는 메모리의 크기를 의미하는 워킹셋(WorkingSet)과 최대 메모리 사용량의 차이가 클수록 시스템의 활용률을 낮출 수 밖에 없다. 이를 개선하기 위해서는 꾸준히 재접근되지 않는 메모리를 반환해야 하는데, 스왑이 없으면 익명 페이지는 반환 자체를 할 수 없다.\n스왑이 없으면 익명 페이지를 반환할 수 없는데, 왜 쿠버네티스는 그 동안 스왑을 허용하지 않았을까? 여러 가지 이유가 있겠지만, 과거부터 주로 언급되던 스왑의 문제는 전반적인 성능에 대한 불확실성을 높인다는 것이다. 하지만, 최근 디스크의 입출력 속도와 스왑 관련 리눅스 커널 코드가 많이 개선되었고, 다양한 사용자들이 꾸준히 요청해왔기 때문에 쿠버네티스에서도 공식적으로 스왑을 지원하게 되었다.\n우선 스왑이 없는 환경에서 구체적으로 어떤 문제가 발생하는지 간단한 실험을 통해 살펴보자. 아래 그림은 노드의 허용량(Capacity)까지 스파크 스트리밍을 배포했을 때 반복적으로 노드가 동작불능 상태가 되면서 모든 파드가 추출된 상황을 보여주고 있다. (요청량(Requests)이 없는 파드때문에 실제 사용량은 요청량을 초과한다.)\n\n스파크 스트리밍은 익명 페이지를 주로 사용하기 때문에 반환할 수 없는 메모리(노란색)가 지속적으로 증가하면서 페이지 캐시(하늘색)는 감소하는 모습을 볼 수 있다. 임계점(~05:00)에 가까워지면 시스템의 물리 메모리가 부족해져서 커널이 특정 프로세스를 종료(OOM)시키기도 하지만 바로 재시작하기 때문에, 결국 시스템은 과부하 상태가 된다. 그래서 임계점 직전에 CPU 와 디스크 사용량이 폭발적으로 증가하면서 노드가 동작불능(NotReady) 상태가 되었고, 잠시 후 모든 파드가 추출되면서 메모리가 반환되어 다시 동작가능(Ready) 상태가 되었다.\n이제 스왑이 있는 환경에서 동일한 실험을 해보자. 아래 그림은 위와 마찬가지로 노드의 허용량까지 스파크 스트리밍을 배포했을 때의 상황을 보여주고 있다.\n\n스왑이 없는 경우와 동일하게 익명 페이지 사용량이 지속적으로 증가하면서 페이지 캐시(하늘색)가 감소하지만 동시에 스왑 사용량(붉은색)도 증가하는 것을 볼 수 있다. 스왑 사용량은 어느 정도 증가하다가 더 이상 증가하지 않는 것을 확인할 수 있는데, 이는 간단히 말하면 LRU(LeastRecentlyUsed) 정책에 의해 오래 전에 사용된 페이지들을 우선적으로 스왑 아웃(SwapOut)해서 부족한 메모리를 확보했기 때문에 시스템이 안정적으로 메모리를 할당/해제할 수 있는 상황이 된 것이다.\n이렇게 스왑을 사용해서 시스템은 안정되었지만, 성능적인 문제는 없었을까? 결론부터 말하면 성능 저하는 거의 없다고 할 수 있다. 위의 실험에서 성능은 스파크 스트리밍의 마이크로배치 처리시간으로 검증하였는데, 실제 성능 차이는 전혀 없었다. 그렇다면 왜 성능 차이가 전혀 없을까? 여러 가지 이유가 있겠지만, 가장 중요한 이유는 아래 그래프를 보면 알 수 있다.\n\n위의 그래프에서 보면, 스왑 사용량이 증가할 때(~21:30)는 스왑 아웃(SwapOut)이 꽤 많아보이지만, 이후로는 거의 없어졌다. 즉, 다시 물리 메모리가 부족해져서 스왑을 이용하여 추가 메모리를 확보할 필요가 없어졌다는 의미이다. 그리고 위의 그래프에서 더 중요한 부분은 바로 스왑 인(SwapIn)이 매우 적다는 것이다. 이는 스왑 아웃되었던 페이지를 다시 접근하여 스왑 인되는 상황이 매우 적었다는 말이다. 즉, 다시 접근할 일이 없는 페이지를 잘 골라서 추가 메모리를 확보했다는 의미이다. 이러한 이유로 성능 저하는 거의 없었다고 보면 된다. (하지만, 무리하게 스트리밍을 더 늘리면 어느 시점부터는 스왑 인/아웃이 동시에 증가하면서 성능 저하가 나타나기 시작한다.)\n스왑이 좋은 효과를 볼 수 있는 상황은 최대 메모리 사용량이 물리 메모리보다 크지만 워킹셋은 물리 메모리보다 작은 경우이다. 이는 반복적으로 사용되는 메모리(워킹셋)는 물리 메모리를 항상 차지하고 있는 것이 유리하고, 더 이상 사용되지 않는 메모리는 스왑 아웃되어 물리 메모리를 차지하지 않는 것이 유리하기 때문이다.\n","description":"","id":"https://haruband.github.io/k8s-spark-optimize-swap/","title":"[K8S/Spark] 메모리 최적화 (Swap)"},"https://haruband.github.io/k8s-spark-optimize/":{"body":"우리는 다양한 클라우드 환경을 효율적으로 지원하기 위해 쿠버네티스(K8S)를 기반으로 데이터 플랫폼을 개발 중이고, 하나의 클러스터에서 카프카(Kafka), 스파크(Spark), 트리노(Trino) 등 다양한 서비스들을 동시에 운영하고 있다. 이는 각각의 서비스를 베어메탈(BareMetal) 환경에서 독립적으로 운영하는 것보다 많은 고민과 노력이 필요하고, 오늘은 이러한 환경에서 스파크를 어떻게 최적화해서 사용하고 있는지 몇 가지만 간단히 소개하고자 한다.\n우선, 어떠한 점들을 중요하게 고려하고 있는지 간단히 정리해보도록 하겠다.\n\n컴퓨팅 자원이 부족한 엣지 클라우드\n안정적인 실시간 데이터 수집/보관/처리\n\n보안이 중요한 고객들은 회사 내부에서 클라우드를 직접 운영하는 온프레미스 환경을 선호하기 때문에 컴퓨팅 자원이 부족할 수 밖에 없고, 이러한 환경에서도 안정적으로 실시간 데이터를 수집/보관/처리할 수 있어야 한다.\nGraalVM 을 이용한 물리 메모리 사용량&nbsp;줄이기\n쿠버네티스는 기본적으로 스왑(Swap)을 사용하지 않기 때문에 익명 페이지(AnonPage)를 사용하는 힙(Heap)은 반환(Reclaim)되지 않는다. 그렇기 때문에 스파크에 너무 많은 양을 할당하면 메모리 활용률이 낮아질 수 밖에 없다. 그렇다고 충분한 양을 할당하지 않으면 OOM 이 발생할 수 있기 때문에 약간의 활용률은 희생할 수 밖에 없는 상황이다. 이를 개선하기 위해, 오라클에서 개발 중인 GraalVM 을 적용해보았다. GraalVM 은 기존의 C++ 로 개발되던 자바가상머신(JVM)을 자바로 개발한 것이고, 주요 기능 중 하나가 필요없어진 힙 영역을 커널에 반환하는 기능이다. 간단히 설명하면, 기존에는 GC(GarbageCollection) 에 의해 사용되던 힙이 반환되어도 커널에 반환하지 않았지만, GraalVM 은 GC 에 의해 사용되던 힙이 반환되면 커널에 반환까지 한다. (물론, 자바가상머신에서 사용하는 힙 영역은 익명 페이지를 할당받아서 사용하기 때문에 최소한 페이지 단위로 할당/반환이 이루어진다.)\n\n위의 그래프는 동일한 작업을 하는 스파크 익스큐터(Executor)를 각각 OpenJDK 와 GraalVM 으로 실행했을 때 실제 물리 메모리 사용량인 RSS(Resident Set Size) 를 측정한 결과이다. 비슷한 시점에 MajorGC 가 발생하지만 OpenJDK(노란색) 는 RSS 가 줄어들지 않고 GraalVM(연두색) 은 RSS 가 줄어드는 것을 확인할 수 있다. 하지만, 최대 힙 사용량은 GraalVM 이 더 높기 때문에 유의해서 사용하는 것이 좋을 것 같다.\nTmpFS 를 이용한 디스크 쓰기&nbsp;줄이기\n스파크는 셔플(Shuffle)을 이용하여 데이터를 재분배할 때 로컬 디렉토리(LocalDir)에 셔플을 위해 준비한 데이터 파일을 저장한다. 해당 데이터 파일은 작업이 종료된 후 GC 에 의해 셔플 객체가 반환될 때 같이 지워지는데, 데이터 파일이 지워지기 전에 (커널의 기본 설정에 의해) 페이지 캐시가 반영(Writeback)되어 불필요한 디스크 쓰기가 주기적으로(마이크로배치 간격으로) 발생하였다. 이를 해결하기 위해 로컬 디렉토리로 메모리 기반 파일시스템인 TmpFS 를 사용하였고, 결과는 아래와 같다.\n\n위의 그래프에서 볼 수 있는 것처럼, 로컬 디렉토리로 Ext4FS(연두색) 를 사용한 경우에는 마이크로배치(1 분)마다 200~300 KBytes 정도의 디스크 쓰기가 발생하였고, TmpFS(노란색) 를 사용한 경우에는 동일한 상황에서 80 KBytes 미만의 디스크 쓰기가 발생하였다. 이는 입력 데이터의 크기가 커질수록 셔플에 사용되는 데이터 파일의 크기가 커지기 때문에 심각한 문제를 발생시킬 수 있다.\n스왑을 이용한 물리 메모리 활용률&nbsp;높이기\n컴퓨팅 자원을 최대한 활용하기 위해 노드의 허용량(Capacity)까지 스파크 스트리밍을 배포해보았다. 노드에 설치된 메모리가 256 GBytes 이기 때문에 하나의 드라이버(4 GBytes)와 하나의 익스큐터(7 GBytes)로 구성된 스트리밍을 총 35 개 정도 배포할 수 있었다. 스파크의 쿠버네티스 스케줄러는 익스큐터 파드에 요청량(Requests)과 제한량(Limits)을 적용하기 때문에 노드의 용량 초과로 더 이상 배포할 수는 없었다. 그러나 노드가 허용하는 범위 내에서 파드를 성공적으로 배포했지만, 노드는 아래와 같이 불안정한 모습을 보였다.\n\n해당 노드에는 요청량이 없는 여러 파드도 동작 중이기 때문에 실제 총 사용량은 총 요청량을 초과할 것이다. 그리고 쿠버네티스는 기본적으로 스왑을 사용하지 않기 때문에 대부분의 공간을 차지하는 익명 페이지는 반환이 불가능하다. 그래서 위의 그래프를 보면 페이지 캐시 사용량(하늘색)이 감소하다가 0 에 가까워지면 더 이상 추가 메모리를 확보할 수 없게 되면서 시스템이 불안정해진다. 위의 경우는 시스템이 불안정해지면서 노드가 동작불능(NotReady) 상태가 되고, 이 상태가 일정시간(PodEvictionTimeout) 이상 지속되면 해당 노드의 모든 파드가 추출되어 파드가 사용 중이던 메모리가 반환되면서 다시 노드가 동작가능(Ready) 상태가 된 것이다. 이러한 반복적인 상황을 해결하기 위해 실제 총 사용량을 어느 정도 예측하여 파드를 적절히 배포하면 좋겠지만, 다양한 워크로드가 혼재되어 있는 상황에서 총 사용량을 정확히 예측하기란 불가능에 가깝다.\n우리는 이 문제를 효율적으로 해결하기 위해 쿠버네티스 1.22 버전부터 지원하기 시작한 스왑 기능을 사용하기로 하였다. 지금까지 쿠버네티스에서 스왑을 지원하지 않았던 이유는 부족한 메모리 대신 느린 디스크를 사용하는 것이 오히려 더 많은 문제를 만든다고 보았기 때문이다. 하지만, 최근 리눅스 커널에서 스왑 관련 기능이 많이 개선되었고, 랜덤 읽기/쓰기 속도가 매우 빠른 SSD 와 NVME 가 일반적으로 널리 쓰이면서 스왑 사용 여부를 사용자가 선택할 수 있는 기능이 추가되었다. 아래는 스왑을 사용하여 위의 실험을 다시 해본 결과이다.\n\n위의 그래프를 보면, 메모리 사용량이 증가하면서 페이지 캐시(하늘색)가 반환되지만 동시에 스왑 사용량(붉은색)도 증가하는 것을 볼 수 있다. 스왑 사용량은 어느 정도 증가하다가 더 이상 증가하지 않는 것을 확인할 수 있는데, 이는 간단히 말하면 LRU(LeastRecentlyUsed) 정책에 의해 오래 전에 사용된 페이지들을 우선적으로 스왑 아웃(SwapOut)해서 부족한 메모리를 확보했기 때문에 시스템이 안정적으로 메모리를 할당/해제할 수 있는 상황이 된 것이다.\n이렇게 스왑을 사용해서 시스템은 안정되었지만, 성능적인 문제는 없었을까? 결론부터 말하면 성능 저하는 거의 없다고 할 수 있다. 위의 실험에서 성능은 스파크 스트리밍의 마이크로배치 처리시간으로 검증하였는데, 실제 성능 차이는 전혀 없었다. 그렇다면 왜 성능 차이가 전혀 없을까? 여러 가지 이유가 있겠지만, 가장 중요한 이유는 아래 그래프를 보면 알 수 있다.\n\n위의 그래프에서 보면, 스왑 사용량이 증가할 때(~21:30)는 스왑 아웃(SwapOut)이 꽤 많아보이지만, 이후로는 거의 없어졌다. 즉, 다시 물리 메모리가 부족해져서 스왑을 이용하여 추가 메모리를 확보할 필요가 없어졌다는 의미이다. 그리고 위의 그래프에서 더 중요한 부분은 바로 스왑 인(SwapIn)이 매우 적다는 것이다. 이는 스왑 아웃되었던 페이지를 다시 접근하여 스왑 인되는 상황이 매우 적었다는 말이다. 즉, 다시 접근할 일이 없는 페이지를 잘 골라서 추가 메모리를 확보했다는 의미이다. 이러한 이유로 성능 저하는 거의 없었다고 보면 된다. (하지만, 무리하게 스트리밍을 더 늘리면 어느 시점부터는 스왑 인/아웃이 동시에 증가하면서 성능 저하가 나타나기 시작한다.)\n스왑이 긍정적인 효과를 내기 위해서는 지속적으로 재접근되는 메모리의 크기를 의미하는 워킹셋(WorkingSet)이 중요한데, 전체 메모리 사용량은 물리 메모리보다 크지만 워킹셋이 물리 메모리보다 작다면 스왑이 좋은 효과를 볼 수 있다. 이는 반복적으로 사용되는 메모리(워킹셋)는 물리 메모리를 항상 차지하고 있는 것이 유리하고, 더 이상 사용되지 않는 메모리는 스왑 아웃되어 물리 메모리를 차지하지 않는 것이 유리하기 때문이다.\n","description":"","id":"https://haruband.github.io/k8s-spark-optimize/","title":"[K8S/Spark] 성능 최적화"},"https://haruband.github.io/k8s-vxlan-forbidden/":{"body":"오늘은 VMWare 기반의 IaaS 를 이용하여 쿠버네티스 클러스터를 구축하던 중 발생했던 문제를 파악하고 해결했던 과정을 간단히 소개해보고자 한다. 해당 문제와 유사한 문제가 다행히(?) AWS EC2 에서도 발생하여 EC2 를 기준으로 설명하도록 하겠다.\n어떠한 문제가 발생했는가???\n우리는 AWS 와 GCP 를 사용할때는 주로 매니지드 쿠버네티스 서비스를 활용하지만, 그렇지 않은 경우에는 kubespray 를 이용하여 쿠버네티스를 설치하고, kustomization 을 기반으로 개발한 IaC(InfrastructureAsCode)를 이용하여 서비스를 배포한다. 그리고 CNI 는 개인적으로 문제 분석과 해결이 용이한 Cilium 을 주로 사용하고 있다.\n일단 상황은 이렇다. 회사 내부에서 딥러닝/빅데이터 클러스터에서 꾸준히 사용해오던 쿠버네티스를 동일한 방식으로 EC2 에 설치했는데 이상한 현상이 발생했다. 처음 접했던 현상은 서비스 디스커버리가 잘(?) 되지 않는 문제였다. 그래서 kibana 와 mongos 같이 서비스 디스커버리를 이용하여 다른 파드에 접근하는 서비스들만 정상적인 동작을 하지 않았다. 이와 같은 현상의 원인을 파악하기 위해 일단은 서비스 디스커버리 쪽을 살펴보기로 했다.\n원인 분석을 위해 클러스터 내부에 jupyterlab 을 설치하고 dig 를 이용하여 서비스 디스커버리가 잘 동작하는지 확인해보았다. nodelocaldns 를 사용 중이고, coredns 는 기본적으로 2개의 파드가 동작 중이다. 일단 nodelocaldns 쪽은 문제가 없다고 판단하여 바로 coredns 서비스로 dig 를 이용하여 질의를 해보았다. 동일한 도메인을 반복적으로 질의해보니 성공과 실패를 반복하는 이상한 현상이 발견되었다. 그래서 이번에는 두 개의 파드(coredns)로 각각 직접 질의를 해보았다. 놀랍게도 하나의 파드는 항상 성공했지만, 다른 하나의 파드는 항상 실패했다.\n두 개의 파드는 하나의 coredns 디플로이먼트로 배포된 완전히 동일한 파드인데 왜 이런 문제가 발생한 것일까? 사실은 두 개의 파드가 완전히 동일한 상황은 아니다. 왜냐하면 두 개의 파드가 서로 다른 노드에 존재하고, 둘 중 하나의 노드에만 jupyterlab 이 존재하기 때문이다. jupyterlab 에서 동일한 방식으로 각각의 파드에 질의를 보냈지만, 결과적으로는 하나의 파드는 같은 노드에 있어서 로컬 통신으로 요청이 잘 처리되었고, 다른 파드는 다른 노드에 있어서 외부 통신을 하던 중 문제가 발생했던 것이다. 즉, 해당 문제는 우리가 처음 접했던 서비스 디스커버리의 문제가 아니고, 네트워킹의 문제였다.\n어떻게 문제가 발생했는가???\n우선 쿠버네티스에서 실제 통신을 처리하는 CNI 를 살펴보았다. 우리는 CNI 로 Cilium 을 사용 중이기 때문에 관련 정보들이 정확히 구성되어있는지 분석해보았다.\n\nCilium 의 2번 서비스를 보면 기본적인 coredns 서비스와 엔드포인트가 정확히 설정되어있는 것을 확인할 수 있다. 다음으로 노드 간 통신을 위해 VXLAN 을 사용 중이기 때문에 아래와 같이 터널링 정보도 확인해보았다.\n\n여기까지 살펴본 바로는 설정에는 아무런 문제가 없었다. 그럼 이제 실제 통신이 제대로 이루어지는지를 살펴보자. 확인을 위해 node1 에 존재하는 jupyterlab 에서 node2 에 있는 파(coredns)로 dig 를 이용하여 질의를 보낼때 node1 과 node2 에서 tcpdump 로 VXLAN 이 사용 중인 8472 UDP 포트를 모니터링하였다. 예상대로 node1 에서는 패킷을 전송하지만, node2 에서 해당 패킷을 수신하지 못했다. 몇 가지를 확인한 결과 AWS EC2 의 보안 그룹 설정에서 모든 UDP 를 막아두고 있었다. 그래서 해당 문제의 원인은 AWS EC2 보안 그룹에서 UDP 를 막아두어서 UDP 를 사용하는 VXLAN 터널링이 제대로 작동하지 않았던 것이다.\n참고로, VXLAN 기반의 터널링을 사용하는 경우, 앱에서 TCP 를 사용하더라도 다른 노드로 패킷을 전달할 때는 IP/UDP 로 한번 더 포장을 해서 전송하기 때문에 실제 노드 간 통신은 UDP 로 이루어진다.\n어떻게 문제를 해결했는가???\n해당 문제를 해결할 수 있는 방법은 두 가지 정도이다.\n\nAWS EC2 보안 그룹 설정 변경\nVXLAN 대신 다이렉트 라우팅 기법 사용\n\n첫 번째 해결책이 간단하지만, 노드의 수가 많지 않고 모든 노드가 하나의 서브넷 안에 있다면 VXLAN 을 사용하지 않고 다이렉트 라우팅 기법을 사용하는 것이 더 나은 해결책일 것이다.\n","description":"","id":"https://haruband.github.io/k8s-vxlan-forbidden/","title":"[K8S] VXLAN 사용 불가 문제 분석"},"https://haruband.github.io/pages/":{"body":"","description":"","id":"https://haruband.github.io/pages/","title":""}},"docInfo":{"https://haruband.github.io/":{"body":0,"description":0,"title":0},"https://haruband.github.io/about/":{"body":79,"description":0,"title":0},"https://haruband.github.io/archive/":{"body":0,"description":0,"title":0},"https://haruband.github.io/blog/":{"body":0,"description":0,"title":0},"https://haruband.github.io/contact/":{"body":16,"description":6,"title":1},"https://haruband.github.io/datafusion-aggregation/":{"body":34,"description":0,"title":2},"https://haruband.github.io/datafusion-benchmark/":{"body":118,"description":0,"title":2},"https://haruband.github.io/datafusion-join/":{"body":32,"description":0,"title":2},"https://haruband.github.io/datafusion-overview/":{"body":106,"description":0,"title":1},"https://haruband.github.io/delta-checkpoints/":{"body":70,"description":0,"title":1},"https://haruband.github.io/delta-cleanup/":{"body":25,"description":0,"title":2},"https://haruband.github.io/delta-filtering/":{"body":33,"description":0,"title":1},"https://haruband.github.io/delta-optimize/":{"body":14,"description":0,"title":1},"https://haruband.github.io/delta-overview/":{"body":35,"description":0,"title":1},"https://haruband.github.io/ebpf-core/":{"body":114,"description":0,"title":7},"https://haruband.github.io/ebpf-loading-jit/":{"body":138,"description":0,"title":3},"https://haruband.github.io/ebpf-loading-memory/":{"body":104,"description":0,"title":2},"https://haruband.github.io/ebpf-loading-program/":{"body":59,"description":0,"title":2},"https://haruband.github.io/images/":{"body":0,"description":0,"title":0},"https://haruband.github.io/k8s-cgroupv2-privatens/":{"body":59,"description":0,"title":3},"https://haruband.github.io/k8s-cni-dsr/":{"body":49,"description":0,"title":5},"https://haruband.github.io/k8s-cni-ipvlan-redirect-bug/":{"body":71,"description":0,"title":4},"https://haruband.github.io/k8s-cni-ipvlan/":{"body":148,"description":0,"title":4},"https://haruband.github.io/k8s-cni-loadbalancing/":{"body":41,"description":0,"title":4},"https://haruband.github.io/k8s-cni-nodeport/":{"body":60,"description":0,"title":2},"https://haruband.github.io/k8s-cni-redirect/":{"body":49,"description":0,"title":2},"https://haruband.github.io/k8s-cni-routing-benchmark/":{"body":76,"description":0,"title":1},"https://haruband.github.io/k8s-cni-service/":{"body":85,"description":0,"title":2},"https://haruband.github.io/k8s-cni-servicemesh-proxy/":{"body":68,"description":0,"title":5},"https://haruband.github.io/k8s-cni-vxlan/":{"body":113,"description":0,"title":4},"https://haruband.github.io/k8s-istio-ambientmesh-cilium/":{"body":65,"description":0,"title":3},"https://haruband.github.io/k8s-istio-ambientmesh-flow/":{"body":122,"description":0,"title":2},"https://haruband.github.io/k8s-istio-ambientmesh-rpfilter/":{"body":64,"description":0,"title":3},"https://haruband.github.io/k8s-istio-ambientmesh/":{"body":72,"description":0,"title":2},"https://haruband.github.io/k8s-kafka-optimize-loadbalancer/":{"body":85,"description":0,"title":2},"https://haruband.github.io/k8s-memory-swap/":{"body":13,"description":0,"title":1},"https://haruband.github.io/k8s-nat-loopback-lrp/":{"body":48,"description":0,"title":3},"https://haruband.github.io/k8s-nat-loopback-snat/":{"body":90,"description":0,"title":3},"https://haruband.github.io/k8s-networkpolicy/":{"body":50,"description":0,"title":3},"https://haruband.github.io/k8s-proxy-bypass/":{"body":49,"description":0,"title":7},"https://haruband.github.io/k8s-qos-memory/":{"body":36,"description":0,"title":2},"https://haruband.github.io/k8s-rpfilter/":{"body":72,"description":0,"title":3},"https://haruband.github.io/k8s-spark-optimize-swap/":{"body":64,"description":0,"title":2},"https://haruband.github.io/k8s-spark-optimize/":{"body":69,"description":0,"title":1},"https://haruband.github.io/k8s-vxlan-forbidden/":{"body":63,"description":0,"title":2},"https://haruband.github.io/pages/":{"body":0,"description":0,"title":0}},"length":46},"lang":"English"}